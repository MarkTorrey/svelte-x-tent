import{eJ as Ue,pF as Ze,dP as B,eK as nt,jk as So,ij as ar,pO as ln,dI as ce,dt as Oi,df as ot,ii as cn,pJ as bo,dq as Z,dp as K,dF as Vt,dj as H,dd as D,cq as hn,cZ as Ge,hH as xo,a1 as dn,aE as ms,aZ as qt,pP as Us,pQ as To,j2 as nr,aF as st,V as u,W as R,j9 as tt,aB as fi,mu as un,cd as Ne,dD as le,pR as Vs,pS as Hs,pT as Or,pU as Mi,dG as kt,dH as pn,pV as Co,eL as Ao,nS as mr,pW as Ro,pX as Gs,gj as Bs,dy as yt,js as Ws,jr as Eo,dE as $o,hN as Do,jc as Ht,dm as k,ls as li,jw as wt,du as He,e5 as Be,dN as te,dw as Po,U as vr,pY as fn,X as We,pZ as mt,fg as Si,bI as bi,eQ as Sr,n3 as qs,p_ as Io,aU as Yt,ae as gi,p$ as vs,lg as or,_ as xi,de as Ti,je as Li,q0 as Fe,dJ as ks,q1 as _s,ic as gn,eC as lr,b8 as Y,n2 as Ys,fn as Mo,dx as Lo,h8 as lt,kh as ht,ki as zt,mt as ii,hL as Js,d8 as Ut,nz as pe,q2 as No,kg as Xs,eP as ys,dh as Xr,q3 as Fo,ja as Zr,e0 as jo,g0 as Zs,jQ as it,q4 as zo,ev as Uo,Y as br,h_ as Qs,a7 as Vo,f$ as Ho,q5 as xr,k$ as Go,q6 as Bo,hS as Wo,q7 as qo,ds as ko,jh as Yo,q8 as Jo,q9 as Xo,bi as Zo,bR as Qo,jK as Ko,qa as el,eF as mn,km as tl,eG as il,jz as rl,qb as sl,qc as al,qd as nl,qe as ol,oR as ll,lt as ws,kH as cl,qf as hl,qg as dl,qh as ul,dV as pl,hh as fl,pC as gl,pD as ml,pE as vl,cy as _l,qi as yl,qj as wl,qk as Ol}from"./index-Cek7aMWl.js";import{o as Sl}from"./floatRGBA-Beo2b9N5.js";import{ag as vn,ah as Kt,ai as Ks,aj as ea,ak as ta,R as cr,w as Ci,x as _n,s as ei,e as ci,al as yn,a3 as T,S as Q,a4 as _r,o as ge,am as ia,l as Os,J as wn,an as Ai,D as Le,ad as bl,t as xl,j as Ss,f as bs,ao as Tl,r as Qr,M as xs,P as Ts,G as Cs,d as _t,z as Ri,A as Ei,X as Zi,Y as As,Z as On,ap as Cl,_ as Rs,$ as Kr,a0 as es,a1 as Sn,aq as Al,ar as ra,as as Rl,at as El,au as $l,av as Dl,B as $i,a5 as Es,a6 as G,W as $e,aw as bn,ax as xn,ae as Ae,y as Pl,ay as Tr,az as Il,aA as Ml,aB as Ll,aC as Nl,aD as Fl,aa as sa,T as jl,O as yr,a as zl,aE as Ul,aF as Qi,af as De,aG as aa,aH as Tn,aI as Vl,aJ as Hl,aK as Cn,F as Gl,aL as Bl,V as na,aM as Wl,aN as ql,aO as kl,aP as Yl,aQ as oa,a8 as Jl,aR as Xl,ac as Zl,aS as Ql,aT as Kl,aU as ec,aV as tc,aW as la,aX as ca,aY as ic,a9 as rc,g as sc,L as ac,i as nc,a2 as oc,a7 as lc,ab as cc}from"./VertexColor.glsl-Op97CNy8.js";import{D as ha,f as hi,E as hr,M as hc,_ as dr,F as dc,R as rt,L as uc,O as pc}from"./enums-BlUEVwJR.js";import{r as re,n as Me,t as da}from"./vec3f32-nZdmKIgz.js";import{t as $s,a as ua}from"./DoubleArray-UXJnwWGc.js";import{A as Ds,l as fc}from"./Indices-CDfjiMVj.js";import{t as F}from"./orientedBoundingBox-BJjR6-FR.js";import{s as ve,m as gc,u as mc,c as At,f as Ni,l as vc}from"./Util-D3WFoRjI.js";import{E as _c,e as m}from"./VertexAttribute-BnAa5VW0.js";import{x as yc}from"./BufferView-D7rTj7nO.js";import{H as xt}from"./InterleavedLayout-DapSkrn-.js";import{o as E,b as wc,g as Ki,c as pa,e as An,d as Cr,f as Ar}from"./NormalAttribute.glsl-Bd6ePXD7.js";import{S as Xe,o as Ps,_ as at,l as Oc,s as Rn,h as Sc}from"./renderState-DVuP8FS-.js";import{t as fa,i as bc,a as xc,e as Is}from"./basicInterfaces-DngWxyLO.js";import{p as ur,a as En}from"./triangulationUtils-WcX9UuuB.js";import{u as Tc}from"./computeTranslationToOriginAndRotation-B1gLm2pX.js";import{Y as Cc,H as Ac,N as Rc,L as Ec,j as Fi}from"./Octree-0huRLiDU.js";import{o as y,n as $n}from"./interfaces-B8ge7Jg9.js";import"./BindType-BmZEZMMh.js";import{b as $c,d as ga,y as ma}from"./axisAngleDegrees-s-Pc0vGJ.js";import{t as Ms}from"./NestedMap-DgiGbX8E.js";import{v as Dn,j as Dc,h as Rr,d as Pc}from"./lineSegment-CMQTKrER.js";import{c as ts,e as Ic}from"./Texture-BjUzSnJr.js";import"./boundedPlane-BL3qgVOW.js";import{t as Mc}from"./glUtil-C6KhMg1m.js";import{i as va,s as Lc}from"./LRUCache-pAqnhOsq.js";import{o as Nc}from"./VertexArrayObject-DSiuLT7k.js";import{c as Fc}from"./BufferObject-Dtd0vzOu.js";function Pn(t){t.code.add(y`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}
const vec4 RGBA_2_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgba2float(vec4 rgba) {
return dot(rgba, RGBA_2_FLOAT_FACTORS);
}`)}var ui,pr,is;(function(t){t[t.RasterImage=0]="RasterImage",t[t.Features=1]="Features"})(ui||(ui={})),function(t){t[t.MapLayer=0]="MapLayer",t[t.ViewLayer=1]="ViewLayer",t[t.Outline=2]="Outline",t[t.SnappingHint=3]="SnappingHint"}(pr||(pr={})),function(t){t[t.WithRasterImage=0]="WithRasterImage",t[t.WithoutRasterImage=1]="WithoutRasterImage"}(is||(is={}));var fr,Ve;(function(t){t[t.ADD=0]="ADD",t[t.UPDATE=1]="UPDATE",t[t.REMOVE=2]="REMOVE"})(fr||(fr={})),function(t){t[t.NONE=0]="NONE",t[t.VISIBILITY=1]="VISIBILITY",t[t.GEOMETRY=2]="GEOMETRY",t[t.TRANSFORMATION=4]="TRANSFORMATION",t[t.HIGHLIGHT=8]="HIGHLIGHT",t[t.OCCLUDEE=16]="OCCLUDEE"}(Ve||(Ve={}));var mi;(function(t){t[t.ASYNC=0]="ASYNC",t[t.SYNC=1]="SYNC"})(mi||(mi={}));let jc=class extends vn{get geometries(){return this._geometries}get transformation(){return this._transformation??Ue}set transformation(e){this._transformation=Ze(this._transformation??B(),e),this._invalidateBoundingVolume(),this._emit("transformationChanged",this)}get shaderTransformation(){return this._shaderTransformation}set shaderTransformation(e){this._shaderTransformation=e?Ze(this._shaderTransformation??B(),e):null,this._invalidateBoundingVolume(),this._emit("shaderTransformationChanged",this)}get effectiveTransformation(){return this.shaderTransformation??this.transformation}constructor(e={}){super(),this.type=Kt.Object,this._shaderTransformation=null,this._parentLayer=null,this._visible=!0,this.castShadow=e.castShadow??!0,this.usesVerticalDistanceToGround=e.usesVerticalDistanceToGround??!1,this.graphicUid=e.graphicUid,this.layerUid=e.layerUid,e.isElevationSource&&(this.lastValidElevationBB=new In),this._geometries=e.geometries?Array.from(e.geometries):new Array}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(e){ve(this._parentLayer==null||e==null,"Object3D can only be added to a single Layer"),this._parentLayer=e}addGeometry(e){e.visible=this._visible,this._geometries.push(e),this._emit("geometryAdded",{object:this,geometry:e}),this._invalidateBoundingVolume()}removeGeometry(e){const i=this._geometries.splice(e,1)[0];i&&(this._emit("geometryRemoved",{object:this,geometry:i}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttributeUpdated(e,i,r=!1){this._emit("attributesChanged",{object:this,geometry:e,attribute:i,sync:r}),_c(i)&&this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(e){if(this._visible!==e){this._visible=e;for(const i of this._geometries)i.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const e=new Ks(fa.MaskOccludee);for(const i of this._geometries)i.occludees=ea(i.occludees,e);return this._emit("occlusionChanged",this),e}removeOcclude(e){for(const i of this._geometries)i.occludees=ta(i.occludees,e);this._emit("occlusionChanged",this)}highlight(){const e=new Ks(fa.Highlight);for(const i of this._geometries)i.highlights=ea(i.highlights,e);return this._emit("highlightChanged",this),e}removeHighlight(e){for(const i of this._geometries)i.highlights=ta(i.highlights,e);this._emit("highlightChanged",this)}getCombinedStaticTransformation(e,i){return nt(i,this.transformation,e.transformation)}getCombinedShaderTransformation(e,i=B()){return nt(i,this.effectiveTransformation,e.transformation)}get boundingVolumeWorldSpace(){return this._bvWorldSpace||(this._bvWorldSpace=this._bvWorldSpace||new _a,this._validateBoundingVolume(this._bvWorldSpace,pi.WorldSpace)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace||(this._bvObjectSpace=this._bvObjectSpace||new _a,this._validateBoundingVolume(this._bvObjectSpace,pi.ObjectSpace)),this._bvObjectSpace}_validateBoundingVolume(e,i){const r=i===pi.ObjectSpace;for(const s of this._geometries){const a=s.boundingInfo;a&&zc(a,e,r?s.transformation:this.getCombinedShaderTransformation(s))}So(ar(e.bounds),e.min,e.max,.5);for(const s of this._geometries){const a=s.boundingInfo;if(a==null)continue;const n=r?s.transformation:this.getCombinedShaderTransformation(s),o=ln(n);ce(ya,a.center,n);const c=Oi(ya,ar(e.bounds)),l=a.radius*o;e.bounds[3]=Math.max(e.bounds[3],c+l)}}_invalidateBoundingVolume(){var i;const e=(i=this._bvWorldSpace)==null?void 0:i.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this._parentLayer&&e&&this._parentLayer.notifyObjectBBChanged(this,e)}_emit(e,i){this._parentLayer&&this._parentLayer.events.emit(e,i)}get test(){}},In=class{constructor(){this.min=ot(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=ot(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}},_a=class extends In{constructor(){super(...arguments),this.bounds=cn()}};function zc(t,e,i){const r=t.bbMin,s=t.bbMax;if(bo(i)){const a=Z(Uc,i[12],i[13],i[14]);K(xe,r,a),K(Pe,s,a);for(let n=0;n<3;++n)e.min[n]=Math.min(e.min[n],xe[n]),e.max[n]=Math.max(e.max[n],Pe[n])}else if(ce(xe,r,i),Vt(r,s))for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],xe[a]),e.max[a]=Math.max(e.max[a],xe[a]);else{ce(Pe,s,i);for(let a=0;a<3;++a)e.min[a]=Math.min(e.min[a],xe[a],Pe[a]),e.max[a]=Math.max(e.max[a],xe[a],Pe[a]);for(let a=0;a<3;++a){H(xe,r),H(Pe,s),xe[a]=s[a],Pe[a]=r[a],ce(xe,xe,i),ce(Pe,Pe,i);for(let n=0;n<3;++n)e.min[n]=Math.min(e.min[n],xe[n],Pe[n]),e.max[n]=Math.max(e.max[n],xe[n],Pe[n])}}}const Uc=D(),xe=D(),Pe=D(),ya=D();var pi;(function(t){t[t.WorldSpace=0]="WorldSpace",t[t.ObjectSpace=1]="ObjectSpace"})(pi||(pi={}));const Vc=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","transformationChanged","shaderTransformationChanged","visibilityChanged","occlusionChanged","highlightChanged","geometryAdded","geometryRemoved","attributesChanged"];let Hc=class extends vn{get objects(){return this._objects}constructor(e,i,r=""){super(),this.stage=e,this.apiLayerUid=r,this.type=Kt.Layer,this.events=new hn,this.visible=!0,this.pickable=!0,this.sliceable=!1,this._objects=new Ge,this._objectsAdded=new Ge,this._handles=new xo,this.apiLayerUid=r,this.visible=(i==null?void 0:i.visible)??!0,this.pickable=(i==null?void 0:i.pickable)??!0,this.updatePolicy=(i==null?void 0:i.updatePolicy)??mi.ASYNC,this._disableOctree=(i==null?void 0:i.disableOctree)??!1,e.add(this);for(const s of Vc)this._handles.add(this.events.on(s,a=>e.handleEvent(s,a)))}destroy(){this._handles.size&&(this._handles.destroy(),this.stage.remove(this),this.invalidateSpatialQueryAccelerator())}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),this._octree!=null&&this._objectsAdded.push(e)}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),this._octree!=null&&(this._objectsAdded.removeUnordered(e)||this._octree.remove([e])))}addMany(e){this._objects.pushArray(e);for(const i of e)i.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),this._octree!=null&&this._objectsAdded.pushArray(e)}removeMany(e){const i=new Array;if(this._objects.removeUnorderedMany(e,e.length,i),i.length!==0){for(const r of i)r.parentLayer=null;if(this.events.emit("layerObjectsRemoved",{layer:this,objects:i}),this._octree!=null){for(let r=0;r<i.length;)this._objectsAdded.removeUnordered(i[r])?(i[r]=i[i.length-1],i.length-=1):++r;this._octree.remove(i)}}}sync(){this.updatePolicy!==mi.SYNC&&this.stage.syncLayer(this.id)}notifyObjectBBChanged(e,i){this._octree==null||this._objectsAdded.includes(e)||this._octree.update(e,i)}getSpatialQueryAccelerator(){return this._octree==null&&this._objects.length>50&&!this._disableOctree?(this._octree=new Cc(e=>e.boundingVolumeWorldSpace.bounds),this._octree.add(this._objects.data,this._objects.length)):this._octree!=null&&this._objectsAdded.length>0&&(this._octree.add(this._objectsAdded.data,this._objectsAdded.length),this._objectsAdded.clear()),this._octree}invalidateSpatialQueryAccelerator(){this._octree=dn(this._octree),this._objectsAdded.clear()}};const Gc={required:[]},Hp={required:[E.Depth]};let Ls=class extends ms{consumes(){return Gc}get usedMemory(){return 0}get isDecoration(){return!1}get running(){return!1}get materialReference(){return null}modify(e){}get numGeometries(){return 0}get hasOccludees(){return!1}queryRenderOccludedState(e){return!1}},Bc=class extends Ls{},Wc=class extends Ls{constructor(){super(...arguments),this.drapedPriority=0}},qp=class extends Ls{},qc=class extends Nc{};var vt,wa,Oa,Sa;(function(t){t[t.INNER=0]="INNER",t[t.OUTER=1]="OUTER"})(vt||(vt={})),function(t){t[t.REGULAR=0]="REGULAR",t[t.HAS_NORTH_POLE=1]="HAS_NORTH_POLE",t[t.HAS_SOUTH_POLE=2]="HAS_SOUTH_POLE",t[t.HAS_BOTH_POLES=3]="HAS_BOTH_POLES"}(wa||(wa={})),function(t){t[t.OFF=0]="OFF",t[t.ON=1]="ON"}(Oa||(Oa={})),function(t){t[t.FADING=0]="FADING",t[t.IMMEDIATE=1]="IMMEDIATE",t[t.UNFADED=2]="UNFADED"}(Sa||(Sa={}));let kc=class{constructor(e,i){this.vec3=e,this.id=i}};function rs(t,e,i,r){return new kc(ot(t,e,i),r)}let ba=class{constructor(){this._extent=qt(),this.resolution=0,this.renderLocalOrigin=rs(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new Yc}get extent(){return this._extent}setupGeometryViewsCyclical(e){this.setupGeometryViewsDirect();const i=.001*e.range;if(this._extent[0]-i<=e.min){const r=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Us(this._extent,e.range,0,r)}if(this._extent[2]+i>=e.max){const r=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Us(this._extent,-e.range,0,r)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,To(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let e=0;e<this.canvasGeometries.numViews;e++){const i=this.canvasGeometries.extents[e];if(i[0]!==i[2]&&i[1]!==i[3])return!0}return!1}},Yc=class{constructor(){this.extents=[qt(),qt(),qt()],this.numViews=0}};var fe;(function(t){t[t.Color=0]="Color",t[t.ColorNoRasterImage=1]="ColorNoRasterImage",t[t.Highlight=2]="Highlight",t[t.WaterNormal=3]="WaterNormal",t[t.Occluded=4]="Occluded",t[t.ObjectAndLayerIdColor=5]="ObjectAndLayerIdColor"})(fe||(fe={}));let Jc=class{constructor(e,i,r){this._fbos=e,this._format=i,this._name=r}get valid(){var e;return((e=this._handle)==null?void 0:e.getTexture())!=null}dispose(){this._handle=nr(this._handle)}get texture(){var e;return(e=this._handle)==null?void 0:e.getTexture()}bind(e,i,r){var s,a,n,o,c,l;this._handle&&((s=this._handle.fbo)==null?void 0:s.width)===i&&((a=this._handle.fbo)==null?void 0:a.height)===r||((n=this._handle)==null||n.release(),this._handle=this._fbos.acquire(i,r,this._name,this._format)),e.unbindTexture((c=(o=this._handle)==null?void 0:o.fbo)==null?void 0:c.colorTexture),e.bindFramebuffer((l=this._handle)==null?void 0:l.fbo)}generateMipMap(){var e,i,r,s,a;(r=(i=(e=this._handle)==null?void 0:e.getTexture())==null?void 0:i.descriptor)!=null&&r.hasMipmap&&((a=(s=this._handle)==null?void 0:s.getTexture())==null||a.generateMipmap())}},Rt=class{constructor(e,i,r,s,a=cr.RGBA_MIPMAP){this.output=r,this.content=s,this.fbo=new Jc(e,a,i)}get valid(){return this.fbo.valid}},Xc=class{constructor(e){this.targets=[new Rt(e,"overlay color",E.Color,fe.Color),new Rt(e,"overlay IM color",E.Color,fe.ColorNoRasterImage),new Rt(e,"overlay highlight",E.Highlight,fe.Highlight,cr.RGBA4),new Rt(e,"overlay water",E.Normal,fe.WaterNormal),new Rt(e,"overlay occluded",E.Color,fe.Occluded)],st("enable-feature:objectAndLayerId-rendering")&&this.targets.push(new Rt(e,"overlay oid",E.ObjectAndLayerIdColor,fe.ObjectAndLayerIdColor))}getTexture(e){var i;return(i=this.targets[e])==null?void 0:i.fbo.texture}dispose(){for(const e of this.targets)e.fbo.dispose()}computeValidity(){return this.targets.reduce((e,i,r)=>i.valid?e|=1<<r:e,0)}};function Zc(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/e)}function Qc(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/i)}function Kc(t,e,i){return 2*Math.atan(e*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}function eh(t,e,i){return 2*Math.atan(i*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}let th=class{constructor(){this.adds=new Ge,this.removes=new Ge,this.updates=new Ge({allocator:e=>e||new ih,deallocator:e=>(e.renderGeometry=null,e)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}get empty(){return this.adds.length===0&&this.removes.length===0&&this.updates.length===0}},ih=class{},rh=class{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}};var xa,z;function sh(t){const e=new Map,i=r=>{let s=e.get(r);return s||(s=new rh,e.set(r,s)),s};return t.removes.forAll(r=>{Er(r)&&i(r.material).removes.push(r)}),t.adds.forAll(r=>{Er(r)&&i(r.material).adds.push(r)}),t.updates.forAll(r=>{Er(r.renderGeometry)&&i(r.renderGeometry.material).updates.push(r)}),e}function Er(t){return t.geometry.indexCount>=1}(function(t){t[t.Default=0]="Default",t[t.Screenshot=1]="Screenshot",t[t.ObjectAndLayerID=2]="ObjectAndLayerID"})(xa||(xa={})),function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"}(z||(z={}));var ss;let M=ss=class extends ms{constructor(t){super(t),this._ray=tt(),this._viewport=fi(0,0,1,1),this._padding=fi(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=un(1,1e3),this._viewDirty=!0,this._viewMatrix=B(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=B(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=B(),this._frustumDirty=!0,this._frustum=Ac(),this._fullViewport=Ne(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=D(),this._up=D(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get rows(){return this._rows}set rows(t){this._rows=Math.max(1,t)}get columns(){return this._columns}set columns(t){this._columns=Math.max(1,t)}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return le(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){Ze(this._viewMatrix,t),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),Z(D(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),Z(D(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),Z(D(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const t=Vs(Ne(),this._viewport,1/this.pixelRatio),e=this._get("screenViewport");return e&&Hs(t,e)?e:t}get screenPadding(){if(this.pixelRatio===1)return this._padding;const t=Vs(Ne(),this._padding,1/this.pixelRatio),e=this._get("screenPadding");return e&&Hs(t,e)?e:t}get x(){return this._viewport[0]}set x(t){t+=this._padding[z.LEFT],this._viewport[0]!==t&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){t+=this._padding[z.BOTTOM],this._viewport[1]!==t&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[z.RIGHT]+this._padding[z.LEFT]}set fullWidth(t){this.width=t-(this._padding[z.RIGHT]+this._padding[z.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[z.TOP]+this._padding[z.BOTTOM]}set fullHeight(t){this.height=t-(this._padding[z.TOP]+this._padding[z.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[z.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[z.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){Or(this._padding,t)||(this._viewport[0]+=t[z.LEFT]-this._padding[z.LEFT],this._viewport[1]+=t[z.BOTTOM]-this._padding[z.BOTTOM],this._viewport[2]-=t[z.RIGHT]+t[z.LEFT]-(this._padding[z.RIGHT]+this._padding[z.LEFT]),this._viewport[3]-=t[z.TOP]+t[z.BOTTOM]-(this._padding[z.TOP]+this._padding[z.BOTTOM]),Mi(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(nt(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){return this._projectionMatrixInternal}get inverseProjectionMatrix(){return kt(B(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||B()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return Kc(this._fov,this.width,this.height)}set fovX(t){this._fov=Zc(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return eh(this._fov,this.width,this.height)}set fovY(t){this._fov=Qc(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return Oi(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(kt(this._viewInverseTransposeMatrix,this.viewMatrix),pn(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const e=2*t-1;return 2*this.near*this.far/(this.far+this.near-e*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}get _projectionMatrixInternal(){const t=this.width,e=this.height,i=this.near*Math.tan(this.fovY/2)*2,r=i*this._aspect,s=i/this.rows,a=r/this.columns,n=-r/2+this.column*a,o=n+a,c=-i/2+this.row*s,l=c+s,h=Co(B(),n*(1+2*this._padding[z.LEFT]/t),o*(1+2*this._padding[z.RIGHT]/t),c*(1+2*this._padding[z.BOTTOM]/e),l*(1+2*this._padding[z.TOP]/e),this.near,this.far),d=this._get("projectionMatrix");return d&&Ao(d,h)?d:h}copyFrom(t){H(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,Mi(this._viewport,t.viewport),this.notifyChange("_viewport"),Mi(this._padding,t.padding),this.notifyChange("_padding"),mr(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.row=t.row,this.column=t.column,this.rows=t.rows,this.columns=t.columns,this.relativeElevation=t.relativeElevation;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||(Ze(this._viewMatrix,t.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||(Rc(this._frustum,t.frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(Ze(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),Mi(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up}clone(){return new ss().copyFrom(this)}equals(t){return Vt(this.eye,t.eye)&&Vt(this.center,t.center)&&Vt(this.up,t.up)&&Or(this._viewport,t.viewport)&&Or(this._padding,t.padding)&&Ro(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation&&this.row===t.row&&this.column===t.column&&this.rows===t.rows&&this.columns===t.columns}almostEquals(t){const e=Math.max(1,1/this.pixelRatio,1/t.pixelRatio);if(Math.abs(t.fov-this._fov)>=.001||Gs(t.screenPadding,this.screenPadding)>=e||Gs(this.screenViewport,t.screenViewport)>=e||this.row!==t.row||this.column!==t.column||this.rows!==t.rows||this.columns!==t.columns)return!1;Bs(he,t.eye,t.center),Bs($r,this.eye,this.center);const i=yt(he,$r),r=Ws(he),s=Ws($r),a=5e-4;return i*i>=(1-1e-10)*r*s&&Eo(t.eye,this.eye)<Math.max(r,s)*a*a}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs($o(this.viewForward,le(he,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=Do()){return t[0]=(this.padding[z.LEFT]+this.width/2)/this.pixelRatio,t[1]=(this.padding[z.TOP]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,i=.5){return t[0]=this.padding[z.LEFT]+this.width*e,t[1]=this.padding[z.BOTTOM]+this.height*i,t[2]=.5,t}setGLViewport(t){const e=this.viewport,i=this.padding;t.setViewport(e[0]-i[3],e[1]-i[2],e[2]+i[1]+i[3],e[3]+i[0]+i[2])}applyProjection(t,e){t!==L&&H(L,t),L[3]=1,Ht(L,L,this.projectionMatrix);const i=Math.abs(L[3]);k(L,L,1/i);const r=this.fullViewport;e[0]=li(0,r[0]+r[2],.5+.5*L[0]),e[1]=li(0,r[1]+r[3],.5+.5*L[1]),e[2]=.5*(L[2]+1),e[3]=i}unapplyProjection(t,e){const i=this.fullViewport;L[0]=(t[0]/(i[0]+i[2])*2-1)*t[3],L[1]=(t[1]/(i[1]+i[3])*2-1)*t[3],L[2]=(2*t[2]-1)*t[3],L[3]=t[3],this.inverseProjectionMatrix!=null&&(Ht(L,L,this.inverseProjectionMatrix),e[0]=L[0],e[1]=L[1],e[2]=L[2])}projectToScreen(t,e){return this.projectToRenderScreen(t,Dr),this.renderToScreen(Dr,e),e}projectToRenderScreen(t,e){if(L[0]=t[0],L[1]=t[1],L[2]=t[2],L[3]=1,Ht(L,L,this.viewProjectionMatrix),L[3]===0)return null;const i=L;k(i,i,1/Math.abs(L[3]));const r=this.fullViewport,s=li(0,r[0]+r[2],.5+.5*i[0]),a=li(0,r[1]+r[3],.5+.5*i[1]);return"x"in e?(e.x=s,e.y=a):(e[0]=s,e[1]=a,e.length>2&&(e[2]=.5*(i[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,Dr),e)}unprojectFromRenderScreen(t,e){if(nt(ji,this.projectionMatrix,this.viewMatrix),!kt(ji,ji))return null;const i=this.fullViewport;return L[0]=2*(t[0]-i[0])/i[2]-1,L[1]=2*(t[1]-i[1])/i[3]-1,L[2]=2*t[2]-1,L[3]=1,Ht(L,L,ji),L[3]===0?null:(e[0]=L[0]/L[3],e[1]=L[1]/L[3],e[2]=L[2]/L[3],e)}constrainWindowSize(t,e,i,r){const s=t*this.pixelRatio,a=e*this.pixelRatio,n=Math.max(s-i/2,0),o=Math.max(this.fullHeight-a-r/2,0),c=-Math.min(s-i/2,0),l=-Math.min(this.fullHeight-a-r/2,0),h=i-c- -Math.min(this.fullWidth-s-i/2,0),d=r-l- -Math.min(a-r/2,0);return[Math.round(n),Math.round(o),Math.round(h),Math.round(d)]}computeUp(t){t===wt.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,e){const i=t[0]*this.pixelRatio,r=this.fullHeight-t[1]*this.pixelRatio;return e[0]=i,e[1]=r,e}renderToScreen(t,e){const i=t[0]/this.pixelRatio,r=(this.fullHeight-t[1])/this.pixelRatio;e[0]=i,e[1]=r}_computeUpGlobal(){le(he,this.center,this.eye);const t=He(this.center);t<1?(Z(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs(yt(he,this.center))>.9999*He(he)*t||(Be(this._up,he,this.center),Be(this._up,this._up,he),te(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){Po(he,this.eye,this.center),Math.abs(he[2])<=.9999&&(k(he,he,he[2]),Z(this._up,-he[0],-he[1],1-he[2]),te(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(t,e,i=""){typeof t[0]=="number"&&isFinite(t[0])&&typeof t[1]=="number"&&isFinite(t[1])&&typeof t[2]=="number"&&isFinite(t[2])?Vt(t,e)||(H(e,t),this._markViewDirty(),i.length&&this.notifyChange(i)):vr.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Ec(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(fn(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};u([R()],M.prototype,"_viewport",void 0),u([R()],M.prototype,"_padding",void 0),u([R()],M.prototype,"_fov",void 0),u([R()],M.prototype,"_nearFar",void 0),u([R()],M.prototype,"_viewDirty",void 0),u([R()],M.prototype,"_viewMatrix",void 0),u([R()],M.prototype,"_pixelRatio",void 0),u([R()],M.prototype,"pixelRatio",null),u([R()],M.prototype,"row",void 0),u([R()],M.prototype,"column",void 0),u([R()],M.prototype,"_rows",void 0),u([R()],M.prototype,"rows",null),u([R()],M.prototype,"_columns",void 0),u([R()],M.prototype,"columns",null),u([R()],M.prototype,"eye",null),u([R()],M.prototype,"center",null),u([R()],M.prototype,"_center",void 0),u([R()],M.prototype,"up",null),u([R()],M.prototype,"_up",void 0),u([R()],M.prototype,"viewMatrix",null),u([R({readOnly:!0})],M.prototype,"viewForward",null),u([R({readOnly:!0})],M.prototype,"viewUp",null),u([R({readOnly:!0})],M.prototype,"viewRight",null),u([R({readOnly:!0})],M.prototype,"nearFar",null),u([R()],M.prototype,"near",null),u([R()],M.prototype,"far",null),u([R()],M.prototype,"viewport",null),u([R({readOnly:!0})],M.prototype,"screenViewport",null),u([R({readOnly:!0})],M.prototype,"screenPadding",null),u([R()],M.prototype,"x",null),u([R()],M.prototype,"y",null),u([R()],M.prototype,"width",null),u([R()],M.prototype,"height",null),u([R()],M.prototype,"fullWidth",null),u([R()],M.prototype,"fullHeight",null),u([R({readOnly:!0})],M.prototype,"_aspect",null),u([R()],M.prototype,"padding",null),u([R({readOnly:!0})],M.prototype,"projectionMatrix",null),u([R({readOnly:!0})],M.prototype,"inverseProjectionMatrix",null),u([R()],M.prototype,"fov",null),u([R()],M.prototype,"fovX",null),u([R()],M.prototype,"fovY",null),u([R()],M.prototype,"viewInverseTransposeMatrix",null),u([R({readOnly:!0})],M.prototype,"_projectionMatrixInternal",null),u([R()],M.prototype,"relativeElevation",void 0),M=ss=u([We("esri.views.3d.webgl.RenderCamera")],M);const wr=M,L=Ne(),ji=B(),he=D(),$r=D(),Dr=mt();var Ta;(function(t){t[t.Material=0]="Material",t[t.ShadowMap=1]="ShadowMap",t[t.Highlight=2]="Highlight",t[t.ViewshedShadowMap=3]="ViewshedShadowMap"})(Ta||(Ta={}));var Gt,as;function ah(t){return t!=null&&!t.running}(function(t){t[t.RENDERING=0]="RENDERING",t[t.FADING=1]="FADING",t[t.FINISHED=2]="FINISHED"})(Gt||(Gt={})),function(t){t[t.RG=0]="RG",t[t.BA=1]="BA"}(as||(as={}));var ns;let zi=ns=class extends bi{constructor(t){super(t),this.type="cloudy",this.cloudCover=.5}clone(){return new ns({cloudCover:this.cloudCover})}};u([Si({cloudy:"cloudy"})],zi.prototype,"type",void 0),u([R({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],zi.prototype,"cloudCover",void 0),zi=ns=u([We("esri.views.3d.environment.CloudyWeather")],zi);var os;let Ui=os=class extends bi{constructor(t){super(t),this.type="foggy",this.fogStrength=.5}clone(){return new os({fogStrength:this.fogStrength})}};u([Si({foggy:"foggy"})],Ui.prototype,"type",void 0),u([R({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],Ui.prototype,"fogStrength",void 0),Ui=os=u([We("esri.views.3d.environment.FoggyWeather")],Ui);var ls;let ri=ls=class extends bi{constructor(t){super(t),this.type="rainy",this.cloudCover=.5,this.precipitation=.5}clone(){return new ls({cloudCover:this.cloudCover,precipitation:this.precipitation})}};u([Si({rainy:"rainy"})],ri.prototype,"type",void 0),u([R({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],ri.prototype,"cloudCover",void 0),u([R({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],ri.prototype,"precipitation",void 0),ri=ls=u([We("esri.views.3d.environment.RainyWeather")],ri);var cs;let Et=cs=class extends bi{constructor(t){super(t),this.type="snowy",this.cloudCover=.5,this.precipitation=.5,this.snowCover="disabled"}clone(){return new cs({cloudCover:this.cloudCover,precipitation:this.precipitation,snowCover:this.snowCover})}};u([Si({snowy:"snowy"})],Et.prototype,"type",void 0),u([R({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],Et.prototype,"cloudCover",void 0),u([R({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],Et.prototype,"precipitation",void 0),u([R({type:["enabled","disabled"],nonNullable:!0,json:{write:!0}})],Et.prototype,"snowCover",void 0),Et=cs=u([We("esri.views.3d.environment.SnowyWeather")],Et);var hs;let Vi=hs=class extends bi{constructor(t){super(t),this.type="sunny",this.cloudCover=.5}clone(){return new hs({cloudCover:this.cloudCover})}};u([Si({sunny:"sunny"})],Vi.prototype,"type",void 0),u([R({type:Number,nonNullable:!0,range:{min:0,max:1},json:{write:!0}})],Vi.prototype,"cloudCover",void 0),Vi=hs=u([We("esri.views.3d.environment.SunnyWeather")],Vi);const $t=1e4,af=1e5;let nh=class{constructor(){this.readChannels=as.RG,this.renderingStage=Gt.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=D(),this.parallax=new Ca,this.parallaxNew=new Ca,this.pointOnGround=D(),this.fadeMode=q.HIDE,this.fadeFactor=0,this.opacity=0}updateParallax(e){const i=this.parallax,r=He(e.eye);if(i.radiusCurvatureCorrectionFactor=.84*Math.sqrt(Math.max(r*r-Sr.radius*Sr.radius,0))/r,ga(Aa,i.anchorPointClouds,Dt),qs(i.transform,Ue,Dt[3],ma(Dt)),this.fadeMode===q.CROSS_FADE){const s=this.parallaxNew;ga(Aa,s.anchorPointClouds,Dt),qs(s.transform,Ue,Dt[3],ma(Dt))}}updateFading(e,i,r,s){this.isFading&&this._advanceFading(r,s),this._evaluateFading(e,i,r)}_evaluateFading(e,i,r){const s=e.relativeElevation,a=this._calculateDistanceToAnchorPoint(e);if((s>1.7*$t||s<-$t||a>dh)&&this.opacity>0)this._setFade(q.HIDE,r);else if(!this.isFading){if((s>$t||s<-.35*$t||a>hh)&&this.opacity>0)this._setFade(q.FADE_OUT,r);else if(s<=$t&&s>=-.35*$t&&i===Io.IDLE&&ah(this.data)){if(this.opacity===0)return void this._setFade(q.FADE_IN,r);(a>ch||this.renderingStage===Gt.FADING)&&this._setFade(q.CROSS_FADE,r)}}}_advanceFading(e,i){this._switchReadChannels(),this._updateAnchorPoint(),this._advanceFadingFactorAndOpacity(e,i)}_advanceFadingFactorAndOpacity(e,i){if(this.fadeFactor<1)return this.fadeFactor=i?Yt((e-this.startTime)/(lh*i),0,1):1,this.fadeMode===q.FADE_OUT&&(this.opacity=1-this.fadeFactor),this.fadeMode===q.FADE_IN&&(this.opacity=this.fadeFactor),void(this.fadeMode===q.CROSS_FADE&&(this.opacity=1));this.fadeFactor=0,this.fadeMode===q.FADE_OUT&&(this.opacity=0),this.fadeMode===q.FADE_IN&&(this.opacity=1),this.fadeMode===q.CROSS_FADE&&(this.opacity=1),this.fadeMode=q.NONE}_switchReadChannels(){const e=this.fadeMode===q.CROSS_FADE&&this.fadeFactor===1,i=this.fadeMode===q.FADE_IN&&this.fadeFactor===0;this.renderingStage===Gt.FADING&&(e||i)&&(this.readChannels=1-this.readChannels,this.renderingStage=Gt.FINISHED)}_calculateDistanceToAnchorPoint(e){return te(this.pointOnGround,e.eye),k(this.pointOnGround,this.pointOnGround,Sr.radius),He(le(oh,this.parallax.anchorPointClouds,this.pointOnGround))}_updateAnchorPoint(){this.fadeMode===q.CROSS_FADE&&(this.fadeFactor===0&&H(this.parallaxNew.anchorPointClouds,this.pointOnGround),this.fadeFactor===1&&H(this.parallax.anchorPointClouds,this.parallaxNew.anchorPointClouds)),this.fadeMode===q.FADE_IN&&this.fadeFactor===0&&H(this.parallax.anchorPointClouds,this.pointOnGround)}_setFade(e,i){switch(e){case q.HIDE:this.opacity=0;break;case q.FADE_OUT:this.opacity=1;break;case q.FADE_IN:this.opacity=0;break;case q.CROSS_FADE:this.opacity=1}this.fadeMode=e,this.fadeFactor=0,this.startTime=i}get isFading(){return this.fadeMode===q.FADE_OUT||this.fadeMode===q.FADE_IN||this.fadeMode===q.CROSS_FADE}};var q;(function(t){t[t.NONE=0]="NONE",t[t.HIDE=1]="HIDE",t[t.FADE_OUT=2]="FADE_OUT",t[t.FADE_IN=3]="FADE_IN",t[t.CROSS_FADE=4]="CROSS_FADE"})(q||(q={}));let Ca=class{constructor(){this.anchorPointClouds=D(),this.radiusCurvatureCorrectionFactor=0,this.transform=B()}};const Aa=ot(0,0,1),Dt=$c(),oh=D(),lh=1.25,ch=34e3,hh=64e3,dh=2e5;var Bt;(function(t){t[t.Disabled=0]="Disabled",t[t.Enabled=1]="Enabled",t[t.EnabledWithWater=2]="EnabledWithWater",t[t.COUNT=3]="COUNT"})(Bt||(Bt={}));let Ns=class extends $n{constructor(){super(...arguments),this.color=ot(1,1,1)}};function Mn(){const t=new Ci;return t.include(_n),t.fragment.uniforms.add(new ei("tex",e=>e.texture),new ci("uColor",e=>e.color)),t.fragment.code.add(y`void main() {
vec4 texColor = texture(tex, uv);
fragColor = texColor * vec4(uColor, 1.0);
}`),t}const uh=Object.freeze(Object.defineProperty({__proto__:null,TextureOnlyPassParameters:Ns,build:Mn},Symbol.toStringTag,{value:"Module"}));let ph=class{constructor(e){this._context=e,this._perConstructorInstances=new Ms,this._frameCounter=0,this._keepAliveFrameCount=Ra}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}destroy(){this._perConstructorInstances.forEach(e=>e.forEach(i=>i.technique.destroy())),this._perConstructorInstances.clear()}acquire(e,i=gh){const r=i.key;let s=this._perConstructorInstances.get(e,r);if(s==null){const a=new e(this._context,i,()=>this.release(a));s=new fh(a),this._perConstructorInstances.set(e,r,s)}return++s.refCount,s.technique}releaseAndAcquire(e,i,r){if(r!=null){if(i.key===r.key)return r;this.release(r)}return this.acquire(e,i)}release(e){if(e==null||this._perConstructorInstances.empty)return;const i=this._perConstructorInstances.get(e.constructor,e.key);i!=null&&(--i.refCount,i.refCount===0&&(i.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==Ra&&this._perConstructorInstances.forEach((e,i)=>{e.forEach((r,s)=>{r.refCount===0&&r.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(r.technique.destroy(),this._perConstructorInstances.delete(i,s))})})}async reloadAll(){const e=new Array;this._perConstructorInstances.forEach((i,r)=>{const s=async(a,n)=>{const o=n.shader;o&&(await o.reload(),a.forEach(c=>c.technique.reload(this._context)))};e.push(s(i,r))}),await Promise.all(e)}},fh=class{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}};const Ra=-1,gh=new yn;let mh=class{constructor(e,i,r,s){this._textures=e,this._techniques=i,this.materialChanged=r,this.requestRender=s,this._id2glMaterialRef=new Ms}dispose(){this._textures.destroy()}acquire(e,i,r){this._ownMaterial(e);const s=e.produces.get(i);if(!(s!=null&&s(r)))return null;let a=this._id2glMaterialRef.get(r,e.id);if(a==null){const n=e.createGLMaterial({material:e,techniques:this._techniques,textures:this._textures,output:r});a=new vh(n),this._id2glMaterialRef.set(r,e.id,a)}return a.ref(),a.glMaterial}release(e,i){const r=this._id2glMaterialRef.get(i,e.id);r!=null&&(r.unref(),r.referenced||(gi(r.glMaterial),this._id2glMaterialRef.delete(i,e.id)))}_ownMaterial(e){e.repository&&e.repository!==this&&vr.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),e.repository=this}},vh=class{constructor(e){this.glMaterial=e,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,ve(this._refCnt>=0)}get referenced(){return this._refCnt>0}};var Ot,vi;(function(t){t[t.Draped=0]="Draped",t[t.Screen=1]="Screen",t[t.World=2]="World",t[t.COUNT=3]="COUNT"})(Ot||(Ot={})),function(t){t[t.Center=0]="Center",t[t.Tip=1]="Tip",t[t.COUNT=2]="COUNT"}(vi||(vi={}));let ne=class extends _r{constructor(){super(...arguments),this.output=E.Color,this.transparencyPassType=Q.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.writeDepth=!1,this.space=Ot.Screen,this.hideOnShortSegments=!1,this.hasCap=!1,this.anchor=vi.Center,this.hasTip=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1}get draped(){return this.space===Ot.Draped}};u([T({count:E.COUNT})],ne.prototype,"output",void 0),u([T({count:Q.COUNT})],ne.prototype,"transparencyPassType",void 0),u([T()],ne.prototype,"occluder",void 0),u([T()],ne.prototype,"hasSlicePlane",void 0),u([T()],ne.prototype,"writeDepth",void 0),u([T({count:Ot.COUNT})],ne.prototype,"space",void 0),u([T()],ne.prototype,"hideOnShortSegments",void 0),u([T()],ne.prototype,"hasCap",void 0),u([T({count:vi.COUNT})],ne.prototype,"anchor",void 0),u([T()],ne.prototype,"hasTip",void 0),u([T()],ne.prototype,"vvSize",void 0),u([T()],ne.prototype,"vvColor",void 0),u([T()],ne.prototype,"vvOpacity",void 0),u([T()],ne.prototype,"hasOccludees",void 0),u([T()],ne.prototype,"multipassEnabled",void 0),u([T()],ne.prototype,"cullAboveGround",void 0),u([T({constValue:!1})],ne.prototype,"occlusionPass",void 0),u([T({constValue:!0})],ne.prototype,"hasVvInstancing",void 0),u([T({constValue:!0})],ne.prototype,"hasSliceTranslatedView",void 0);const Ea=8;function _h(t,e){const i=t.vertex;i.uniforms.add(new ge("intrinsicWidth",r=>r.width)),e.vvSize?(t.attributes.add(m.SIZEFEATUREATTRIBUTE,"float"),i.uniforms.add(new ci("vvSizeMinSize",r=>r.vvSize.minSize),new ci("vvSizeMaxSize",r=>r.vvSize.maxSize),new ci("vvSizeOffset",r=>r.vvSize.offset),new ci("vvSizeFactor",r=>r.vvSize.factor)),i.code.add(y`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(t.attributes.add(m.SIZE,"float"),i.code.add(y`float getSize(){
return intrinsicWidth * size;
}`)),e.vvOpacity?(t.attributes.add(m.OPACITYFEATUREATTRIBUTE,"float"),i.constants.add("vvOpacityNumber","int",8),i.uniforms.add(new ia("vvOpacityValues",r=>r.vvOpacity.values,Ea),new ia("vvOpacityOpacities",r=>r.vvOpacity.opacityValues,Ea)),i.code.add(y`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):i.code.add(y`vec4 applyOpacity( vec4 color ){
return color;
}`),e.vvColor?(t.include(Os,e),t.attributes.add(m.COLORFEATUREATTRIBUTE,"float"),i.code.add(y`vec4 getColor(){
return applyOpacity(interpolateVVColor(colorFeatureAttribute));
}`)):(t.attributes.add(m.COLOR,"vec4"),i.code.add(y`vec4 getColor(){
return applyOpacity(color);
}`))}function Ln(t){return t.pattern.map(e=>Math.round(e*t.pixelRatio))}function yh(t){if(t==null)return 1;const e=Ln(t);return Math.floor(e.reduce((i,r)=>i+r))}function wh(t){return Ln(t).reduce((e,i)=>Math.max(e,i))}function Oh(t){return t==null?vs:t.length===4?t:or(Sh,t[0],t[1],t[2],1)}const Sh=Ne();function bh(t,e){t.constants.add("stippleAlphaColorDiscard","float",.001),t.constants.add("stippleAlphaHighlightDiscard","float",.5),e.stippleEnabled?xh(t,e):Th(t)}function xh(t,e){const i=!(e.draped&&e.stipplePreferContinuous),{vertex:r,fragment:s}=t;s.include(Pn),e.draped||(wn(r,e),r.uniforms.add(new ge("worldToScreenPerDistanceRatio",(a,n)=>1/n.camera.perScreenPixelRatio)),r.code.add(y`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),t.varyings.add("vStippleDistance","float"),t.varyings.add("vStippleDistanceLimits","vec2"),t.varyings.add("vStipplePatternStretch","float"),r.code.add(y`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${Ah};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),r.code.add(y`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),r.code.add(y`
    if (segmentLengthPseudoScreen >= ${i?"patternLength":"1e4"}) {
  `),Ai(r),r.code.add(y`float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
float segmentLengthScreenRounded = flooredRepetitions * patternLength;
float stretch = repetitions / flooredRepetitions;
vStipplePatternStretch = max(0.75, stretch);
return vec2(0.0, segmentLengthScreenRounded);
}
return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
}`),s.uniforms.add(new ei("stipplePatternTexture",a=>a.stippleTexture),new ge("stipplePatternSDFNormalizer",a=>Ch(a.stipplePattern)),new ge("stipplePatternPixelSizeInv",a=>1/Nn(a))),s.code.add(y`float getStippleSDF(out bool isClamped) {
float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;
float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv * vLineSizeInv;
u = fract(u);
float encodedSDF = rgba2float(texture(stipplePatternTexture, vec2(u, 0.5)));
float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;
return (sdf - 0.5) * vStipplePatternStretch + 0.5;
}
float getStippleSDF() {
bool ignored;
return getStippleSDF(ignored);
}
float getStippleAlpha() {
bool isClamped;
float stippleSDF = getStippleSDF(isClamped);
float antiAliasedResult = clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);
return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
}`),e.stippleOffColorEnabled?(s.uniforms.add(new Le("stippleOffColor",a=>Oh(a.stippleOffColor))),s.code.add(y`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):s.code.add(y`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function Th(t){t.fragment.code.add(y`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}function Ch(t){return t?(Math.floor(.5*(wh(t)-1))+.5)/t.pixelRatio:1}function Nn(t){const e=t.stipplePattern;return e?yh(t.stipplePattern)/e.pixelRatio:1}const Ah=y.float(.4),Fn=128,jn=.5;function ff(t){return t==="cross"||t==="x"}function gf(t,e=Fn,i=e*jn,r=0){const s=Rh(t,e,i,r);return new bl(s,{mipmap:!1,wrap:{s:ha.CLAMP_TO_EDGE,t:ha.CLAMP_TO_EDGE},width:e,height:e,components:4,noUnpackFlip:!0,reloadable:!0})}function Rh(t,e=Fn,i=e*jn,r=0){switch(t){case"circle":default:return Eh(e,i);case"square":return $h(e,i);case"cross":return Ph(e,i,r);case"x":return Ih(e,i,r);case"kite":return Dh(e,i);case"triangle":return Mh(e,i);case"arrow":return Lh(e,i)}}function Eh(t,e){const i=t/2-.5;return Di(t,Vn(i,i,e/2))}function $h(t,e){return zn(t,e,!1)}function Dh(t,e){return zn(t,e,!0)}function Ph(t,e,i=0){return Un(t,e,!1,i)}function Ih(t,e,i=0){return Un(t,e,!0,i)}function Mh(t,e){return Di(t,Hn(t/2,e,e/2))}function Lh(t,e){const i=e,r=e/2,s=t/2,a=.8*i,n=Vn(s,(t-e)/2-a,Math.sqrt(a*a+r*r)),o=Hn(s,i,r);return Di(t,(c,l)=>Math.max(o(c,l),-n(c,l)))}function zn(t,e,i){return i&&(e/=Math.SQRT2),Di(t,(r,s)=>{let a=r-.5*t+.25,n=.5*t-s-.75;if(i){const o=(a+n)/Math.SQRT2;n=(n-a)/Math.SQRT2,a=o}return Math.max(Math.abs(a),Math.abs(n))-.5*e})}function Un(t,e,i,r=0){e-=r,i&&(e*=Math.SQRT2);const s=.5*e;return Di(t,(a,n)=>{let o,c=a-.5*t,l=.5*t-n-1;if(i){const h=(c+l)/Math.SQRT2;l=(l-c)/Math.SQRT2,c=h}return c=Math.abs(c),l=Math.abs(l),o=c>l?c>s?Math.sqrt((c-s)*(c-s)+l*l):l:l>s?Math.sqrt(c*c+(l-s)*(l-s)):c,o-=r/2,o})}function Vn(t,e,i){return(r,s)=>{const a=r-t,n=s-e;return Math.sqrt(a*a+n*n)-i}}function Hn(t,e,i){const r=Math.sqrt(e*e+i*i);return(s,a)=>{const n=Math.abs(s-t)-i,o=a-t+e/2+.75,c=(e*n+i*o)/r,l=-o;return Math.max(c,l)}}function Di(t,e){const i=new Uint8Array(4*t*t);for(let r=0;r<t;r++)for(let s=0;s<t;s++){const a=s+t*r;let n=e(s,r);n=n/t+.5,Sl(n,i,4*a)}return i}const Gn=64,Nh=Gn/2,Fh=Nh/5,jh=Gn/Fh,mf=.25;function zh(t,e){const{vertex:i,constants:r}=t;r.add("markerSizePerLineWidth","float",jh),Ai(i),i.uniforms.get("markerScale")==null&&i.constants.add("markerScale","float",1),i.code.add(y`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`),e.space===Ot.World&&(i.constants.add("maxSegmentLengthFraction","float",.45),i.uniforms.add(new ge("perRenderPixelRatio",(s,a)=>a.camera.perRenderPixelRatio)),i.code.add(y`bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}
float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}`))}var St;(function(t){t[t.BUTT=0]="BUTT",t[t.SQUARE=1]="SQUARE",t[t.ROUND=2]="ROUND",t[t.COUNT=3]="COUNT"})(St||(St={}));let W=class extends _r{constructor(){super(...arguments),this.output=E.Color,this.capType=St.BUTT,this.transparencyPassType=Q.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.applyMarkerOffset=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.wireframe=!1,this.objectAndLayerIdColorInstanced=!1}};u([T({count:E.COUNT})],W.prototype,"output",void 0),u([T({count:St.COUNT})],W.prototype,"capType",void 0),u([T({count:Q.COUNT})],W.prototype,"transparencyPassType",void 0),u([T()],W.prototype,"occluder",void 0),u([T()],W.prototype,"hasSlicePlane",void 0),u([T()],W.prototype,"hasPolygonOffset",void 0),u([T()],W.prototype,"writeDepth",void 0),u([T()],W.prototype,"draped",void 0),u([T()],W.prototype,"stippleEnabled",void 0),u([T()],W.prototype,"stippleOffColorEnabled",void 0),u([T()],W.prototype,"stipplePreferContinuous",void 0),u([T()],W.prototype,"roundJoins",void 0),u([T()],W.prototype,"applyMarkerOffset",void 0),u([T()],W.prototype,"vvSize",void 0),u([T()],W.prototype,"vvColor",void 0),u([T()],W.prototype,"vvOpacity",void 0),u([T()],W.prototype,"falloffEnabled",void 0),u([T()],W.prototype,"innerColorEnabled",void 0),u([T()],W.prototype,"hasOccludees",void 0),u([T()],W.prototype,"multipassEnabled",void 0),u([T()],W.prototype,"cullAboveGround",void 0),u([T()],W.prototype,"wireframe",void 0),u([T()],W.prototype,"objectAndLayerIdColorInstanced",void 0),u([T({constValue:!1})],W.prototype,"occlusionPass",void 0),u([T({constValue:!0})],W.prototype,"hasVvInstancing",void 0),u([T({constValue:!0})],W.prototype,"hasSliceTranslatedView",void 0);const _i=1;function Bn(t){const e=new Ci,{attributes:i,varyings:r,constants:s,vertex:a,fragment:n}=e;e.include(xl),e.include(_h,t),e.include(bh,t);const o=t.applyMarkerOffset&&!t.draped;o&&(a.uniforms.add(new ge("markerScale",g=>g.markerScale)),e.include(zh,{space:Ot.World,draped:!1})),e.include(Ss,t),bs(a,t),a.uniforms.add(new Tl("inverseProjectionMatrix",(g,v)=>v.camera.inverseProjectionMatrix),new Qr("nearFar",(g,v)=>v.camera.nearFar),new ge("miterLimit",g=>g.join!=="miter"?0:g.miterLimit),new Le("viewport",(g,v)=>v.camera.fullViewport)),a.constants.add("LARGE_HALF_FLOAT","float",65500),i.add(m.POSITION,"vec3"),i.add(m.PREVPOSITION,"vec3"),i.add(m.NEXTPOSITION,"vec3"),i.add(m.SUBDIVISIONFACTOR,"float"),i.add(m.UV0,"vec2"),r.add("vColor","vec4"),r.add("vpos","vec3"),r.add("vLineDistance","float"),r.add("vLineWidth","float");const c=t.multipassEnabled&&t.output===E.Color;c&&r.add("depth","float");const l=t.stippleEnabled;l&&r.add("vLineSizeInv","float"),s.add("aaWidth","float",t.stippleEnabled?0:1);const h=t.capType===St.ROUND,d=t.stippleEnabled&&h,p=t.falloffEnabled||d;p&&r.add("vLineDistanceNorm","float"),h&&(r.add("vSegmentSDF","float"),r.add("vReverseSegmentSDF","float")),a.code.add(y`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),a.code.add(y`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),a.code.add(y`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${c?"depth = pos.z;":""}

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),Ai(a),a.code.add(y`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;
      float lineSize = getSize();

      if (lineSize < 1.0) {
        coverage = lineSize; // convert sub-pixel coverage to alpha
        lineSize = 1.0;
      }
      lineSize += aaWidth;

      float lineWidth = lineSize * pixelRatio;
      vLineWidth = lineWidth;
      ${l?y`vLineSizeInv = 1.0 / lineSize;`:""}

      vec4 pos  = view * vec4(position, 1.0);
      vec4 prev = view * vec4(prevPosition, 1.0);
      vec4 next = view * vec4(nextPosition, 1.0);
  `),o&&a.code.add(y`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos, other);
if(!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;
}`),a.code.add(y`clipAndTransform(pos, prev, next, isStartVertex);
vec2 left = (pos.xy - prev.xy);
vec2 right = (next.xy - pos.xy);
float leftLen = length(left);
float rightLen = length(right);`),(t.stippleEnabled||h)&&a.code.add(y`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${h?y`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),a.code.add(y`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),t.roundJoins?a.code.add(y`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${t.stippleEnabled?y`min(1.0, subdivisionFactor * ${y.float((_i+2)/(_i+1))})`:y`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `):a.code.add(y`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const f=t.capType!==St.BUTT;return a.code.add(y`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${f?y`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),a.code.add(y`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;
    float lineDistNorm = sign(uv0.y) * pos.w;

    vLineDistance =  lineWidth * lineDistNorm;
    ${p?y`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),h&&a.code.add(y`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),t.stippleEnabled&&(t.draped?a.uniforms.add(new ge("worldToScreenRatio",(g,v)=>1/v.screenToPCSRatio)):a.code.add(y`vec3 segmentCenter = mix((nextPosition + position) * 0.5, (position + prevPosition) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),a.code.add(y`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(nextPosition - position, position - prevPosition, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),t.draped?a.code.add(y`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):a.code.add(y`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),a.uniforms.add(new ge("stipplePatternPixelSize",g=>Nn(g))),a.code.add(y`float patternLength = lineSize * stipplePatternPixelSize;
vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);
vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);
if (segmentLengthScreenDouble >= 0.001) {
vec2 stippleDisplacement = pos.xy - segmentOrigin;
float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);
vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
}
vStippleDistanceLimits *= pos.w;
vStippleDistance *= pos.w;
vStippleDistanceLimits = isJoin ?
vStippleDistanceLimits :
isStartVertex ?
vec2(-1e34, vStippleDistanceLimits.y) :
vec2(vStippleDistanceLimits.x, 1e34);`)),a.code.add(y`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${t.wireframe&&!t.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }
  }
  `),c&&e.include(xs,t),e.include(Ts,t),n.include(Cs),n.code.add(y`
  void main() {
    discardBySlice(vpos);
    ${c?"terrainDepthTest(depth);":""}
  `),t.wireframe?n.code.add(y`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(h&&n.code.add(y`
        float sdf = min(vSegmentSDF, vReverseSegmentSDF);
        vec2 fragmentPosition = vec2(
          min(sdf, 0.0),
          vLineDistance
        ) * gl_FragCoord.w;

        float fragmentRadius = length(fragmentPosition);
        float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
        float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

        if (capCoverage < ${y.float(_t)}) {
          discard;
        }
      `),d?n.code.add(y`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${y.float(_t)}, stippleCoverage);
      `):n.code.add(y`float stippleAlpha = getStippleAlpha();`),t.output!==E.ObjectAndLayerIdColor&&n.code.add(y`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`),n.uniforms.add(new Le("intrinsicColor",g=>g.color)),n.code.add(y`vec4 color = intrinsicColor * vColor;`),t.innerColorEnabled&&(n.uniforms.add(new Le("innerColor",g=>g.innerColor??g.color),new ge("innerWidth",(g,v)=>g.innerWidth*v.camera.pixelRatio)),n.code.add(y`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),n.code.add(y`vec4 finalColor = blendStipple(color, stippleAlpha);`),t.falloffEnabled&&(n.uniforms.add(new ge("falloff",g=>g.falloff)),n.code.add(y`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`)),t.stippleEnabled||n.code.add(y`float featherStartDistance = max(vLineWidth - 2.0, 0.0);
float value = abs(vLineDistance) * gl_FragCoord.w;
float feather = (value - featherStartDistance) / (vLineWidth - featherStartDistance);
finalColor.a *= 1.0 - clamp(feather, 0.0, 1.0);`)),t.transparencyPassType===Q.ColorAlpha&&(e.outputs.add("fragColor","vec4",0),e.outputs.add("fragAlpha","float",1)),n.code.add(y`
    ${t.output===E.ObjectAndLayerIdColor?y`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${y.float(_t)}) {
      discard;
    }

    ${t.output===E.Color?y`fragColor = highlightSlice(finalColor, vpos);`:""}
    ${t.output===E.Color&&t.transparencyPassType===Q.ColorAlpha?y`
            fragColor = premultiplyAlpha(fragColor);
            fragAlpha = fragColor.a;`:""}
    ${t.output===E.Highlight?y`fragColor = vec4(1.0);`:""}
    ${t.output===E.ObjectAndLayerIdColor?y`outputObjectAndLayerIdColor();`:""}
  }
  `),e}const Uh=Object.freeze(Object.defineProperty({__proto__:null,build:Bn,ribbonlineNumRoundJoinSubdivisions:_i},Symbol.toStringTag,{value:"Module"})),Wn=new Map([[m.POSITION,0],[m.PREVPOSITION,1],[m.NEXTPOSITION,2],[m.SUBDIVISIONFACTOR,3],[m.UV0,4],[m.COLOR,5],[m.COLORFEATUREATTRIBUTE,5],[m.SIZE,6],[m.SIZEFEATUREATTRIBUTE,6],[m.OPACITYFEATUREATTRIBUTE,7],[m.OBJECTANDLAYERIDCOLOR,8]]);let qn=class kn extends Ri{initializeProgram(e){return new Ei(e.rctx,kn.shader.get().build(this.configuration),Wn)}_makePipelineState(e,i){const r=this.configuration,s=e===Q.NONE,a=e===Q.FrontFace,n=wc(r.output);return Xe({blending:r.output===E.Color?s?Zi:As(e):null,depthTest:{func:On(e)},depthWrite:s?r.writeDepth||n?Ps:null:Cl(e),drawBuffers:r.output===E.Depth?{buffers:[hi.NONE]}:Rs(e),colorWrite:at,stencilWrite:r.hasOccludees?Kr:null,stencilTest:r.hasOccludees?i?es:Sn:null,polygonOffset:s||a?r.hasPolygonOffset?$a:null:Al})}initializePipeline(){const e=this.configuration;if(e.occluder){const i=e.hasPolygonOffset?$a:null;this._occluderPipelineTransparent=Xe({blending:Zi,polygonOffset:i,depthTest:ra,depthWrite:null,colorWrite:at,stencilWrite:null,stencilTest:Rl,drawBuffers:e.output===E.Depth?{buffers:[hi.NONE]}:null}),this._occluderPipelineOpaque=Xe({blending:Zi,polygonOffset:i,depthTest:ra,depthWrite:null,colorWrite:at,stencilWrite:El,stencilTest:$l,drawBuffers:e.output===E.Depth?{buffers:[hi.NONE]}:null}),this._occluderPipelineMaskWrite=Xe({blending:null,polygonOffset:i,depthTest:Dl,depthWrite:null,colorWrite:null,stencilWrite:Kr,stencilTest:es,drawBuffers:e.output===E.Depth?{buffers:[hi.NONE]}:null})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?hr.LINES:hr.TRIANGLE_STRIP}getPipeline(e,i,r){return e?this._occludeePipelineState:this.configuration.occluder?r?this._occluderPipelineTransparent:i?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipeline()}};qn.shader=new $i(Uh,()=>xi(()=>Promise.resolve().then(()=>sp),void 0,import.meta.url));const $a={factor:0,units:-4};var Se;(function(t){t[t.LEFT_JOIN_START=-2]="LEFT_JOIN_START",t[t.LEFT_JOIN_END=-1]="LEFT_JOIN_END",t[t.LEFT_CAP_START=-4]="LEFT_CAP_START",t[t.LEFT_CAP_END=-5]="LEFT_CAP_END",t[t.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",t[t.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",t[t.RIGHT_CAP_START=4]="RIGHT_CAP_START",t[t.RIGHT_CAP_END=5]="RIGHT_CAP_END"})(Se||(Se={}));let Vh=class extends Es{constructor(e){super(e,new Gh),this._configuration=new W,this.produces=new Map([[G.OPAQUE_MATERIAL,i=>i===E.Highlight||i===E.ObjectAndLayerIdColor||i===E.Color&&this.parameters.renderOccluded===$e.OccludeAndTransparentStencil],[G.OPAQUE_NO_SSAO_DEPTH,i=>Ki(i)],[G.OCCLUDER_MATERIAL,i=>pa(i)&&this.parameters.renderOccluded===$e.OccludeAndTransparentStencil],[G.TRANSPARENT_OCCLUDER_MATERIAL,i=>pa(i)&&this.parameters.renderOccluded===$e.OccludeAndTransparentStencil],[G.TRANSPARENT_MATERIAL,i=>i===E.Color&&this.parameters.writeDepth&&this.parameters.renderOccluded!==$e.OccludeAndTransparentStencil],[G.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,i=>i===E.Color&&!this.parameters.writeDepth&&this.parameters.renderOccluded!==$e.OccludeAndTransparentStencil],[G.DRAPED_MATERIAL,i=>An(i)]]),this._vertexAttributeLocations=Wn}getConfiguration(e,i){this._configuration.output=e,this._configuration.draped=i.slot===G.DRAPED_MATERIAL;const r=this.parameters.stipplePattern!=null&&e!==E.Highlight;return this._configuration.stippleEnabled=r,this._configuration.stippleOffColorEnabled=r&&this.parameters.stippleOffColor!=null,this._configuration.stipplePreferContinuous=r&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins=this.parameters.join==="round",this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=this.parameters.markerParameters!=null&&Wh(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&this.parameters.innerColor!=null,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===$e.OccludeAndTransparentStencil,this._configuration.transparencyPassType=i.transparencyPassType,this._configuration.multipassEnabled=i.multipassEnabled,this._configuration.cullAboveGround=i.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(e,i,r,s,a,n){if(!r.options.selectionMode)return;const o=e.attributes.get(m.POSITION).data,c=e.attributes.get(m.SIZE);let l=this.parameters.width;if(this.parameters.vvSize){const v=e.attributes.get(m.SIZEFEATUREATTRIBUTE).data[0];l*=Yt(this.parameters.vvSize.offset[0]+v*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else c&&(l*=c.data[0]);const h=s[0],d=s[1],p=(l/2+4)*e.screenToWorldRatio;let f=Number.MAX_VALUE,g=0;for(let v=0;v<o.length-5;v+=3){const O=o[v],S=o[v+1],_=h-O,b=d-S,C=o[v+3]-O,x=o[v+4]-S,$=Yt((C*_+x*b)/(C*C+x*x),0,1),w=C*$-_,V=x*$-b,U=w*w+V*V;U<f&&(f=U,g=v/3)}f<p*p&&a(n.dist,n.normal,g,!1)}intersect(e,i,r,s,a,n){if(!r.options.selectionMode||!e.visible)return;if(!gc(i))return void vr.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const o=e.attributes,c=o.get(m.POSITION).data;let l=this.parameters.width;if(this.parameters.vvSize){const _=o.get(m.SIZEFEATUREATTRIBUTE).data[0];l*=Yt(this.parameters.vvSize.offset[0]+_*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else o.has(m.SIZE)&&(l*=o.get(m.SIZE).data[0]);const h=r.camera,d=qh;mr(d,r.point);const p=l*h.pixelRatio/2+4*h.pixelRatio;Z(si[0],d[0]-p,d[1]+p,0),Z(si[1],d[0]+p,d[1]+p,0),Z(si[2],d[0]+p,d[1]-p,0),Z(si[3],d[0]-p,d[1]-p,0);for(let _=0;_<4;_++)if(!h.unprojectFromRenderScreen(si[_],Je[_]))return;Li(h.eye,Je[0],Je[1],Ir),Li(h.eye,Je[1],Je[2],Mr),Li(h.eye,Je[2],Je[3],Lr),Li(h.eye,Je[3],Je[0],Nr);let f=Number.MAX_VALUE,g=0;const v=Yn(this.parameters,o)?c.length-2:c.length-5;for(let _=0;_<v;_+=3){_e[0]=c[_]+i[12],_e[1]=c[_+1]+i[13],_e[2]=c[_+2]+i[14];const b=(_+3)%c.length;if(ye[0]=c[b]+i[12],ye[1]=c[b+1]+i[13],ye[2]=c[b+2]+i[14],Fe(Ir,_e)<0&&Fe(Ir,ye)<0||Fe(Mr,_e)<0&&Fe(Mr,ye)<0||Fe(Lr,_e)<0&&Fe(Lr,ye)<0||Fe(Nr,_e)<0&&Fe(Nr,ye)<0)continue;if(h.projectToRenderScreen(_e,ut),h.projectToRenderScreen(ye,pt),ut[2]<0&&pt[2]>0){le(je,_e,ye);const x=h.frustum,$=-Fe(x[Fi.NEAR],_e)/yt(je,ks(x[Fi.NEAR]));k(je,je,$),K(_e,_e,je),h.projectToRenderScreen(_e,ut)}else if(ut[2]>0&&pt[2]<0){le(je,ye,_e);const x=h.frustum,$=-Fe(x[Fi.NEAR],ye)/yt(je,ks(x[Fi.NEAR]));k(je,je,$),K(ye,ye,je),h.projectToRenderScreen(ye,pt)}else if(ut[2]<0&&pt[2]<0)continue;ut[2]=0,pt[2]=0;const C=Dc(Rr(ut,pt,Ia),d);C<f&&(f=C,H(Da,_e),H(Pa,ye),g=_/3)}const O=r.rayBegin,S=r.rayEnd;if(f<p*p){let _=Number.MAX_VALUE;if(Pc(Rr(Da,Pa,Ia),Rr(O,S,kh),dt)){le(dt,dt,O);const b=He(dt);k(dt,dt,1/b),_=b/Oi(O,S)}n(_,dt,g,!1)}}get _layout(){const e=xt().vec3f(m.POSITION).vec3f(m.PREVPOSITION).vec3f(m.NEXTPOSITION).f32(m.SUBDIVISIONFACTOR).vec2f(m.UV0);return this.parameters.vvSize?e.f32(m.SIZEFEATUREATTRIBUTE):e.f32(m.SIZE),this.parameters.vvColor?e.f32(m.COLORFEATUREATTRIBUTE):e.vec4f(m.COLOR),this.parameters.vvOpacity&&e.f32(m.OPACITYFEATUREATTRIBUTE),st("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(m.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new Bh(this._layout,this.parameters)}createGLMaterial(e){return new Hh(e)}validateParameters(e){e.join!=="miter"&&(e.miterLimit=0),e.markerParameters!=null&&(e.markerScale=e.markerParameters.width/e.width)}},Hh=class extends bn{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextures.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output===E.Color&&this._updateOccludeeState(e);const i=this._material.parameters.stipplePattern;return this._stipplePattern!==i&&(this._material.setParameters({stippleTexture:this._stippleTextures.swap(i,this._stipplePattern)}),this._stipplePattern=i),this.ensureTechnique(qn,e)}},Gh=class extends xn{constructor(){super(...arguments),this.width=0,this.color=_s,this.join="miter",this.cap=St.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}},Bh=class{constructor(e,i){this.vertexBufferLayout=e,this._parameters=i,this.numJoinSubdivisions=0;const r=i.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=r;break;case"round":this.numJoinSubdivisions=_i+r}}_isClosed(e){return Yn(this._parameters,e.attributes)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const r=e.attributes.get(m.POSITION).indices.length/2+1,s=this._isClosed(e);let a=s?2:2*2;return a+=((s?r:r-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),a+=2,this._parameters.wireframe&&(a=2+4*(a-2)),a}write(e,i,r,s,a){var Tt,Pi,I;const n=Yh,o=Jh,c=Xh,l=r.attributes.get(m.POSITION),h=l.indices,d=l.data.length/3,p=(Tt=r.attributes.get(m.DISTANCETOSTART))==null?void 0:Tt.data;h&&h.length!==2*(d-1)&&console.warn("RibbonLineMaterial does not support indices");const f=((Pi=r.attributes.get(m.SIZEFEATUREATTRIBUTE))==null?void 0:Pi.data[0])??((I=r.attributes.get(m.SIZE))==null?void 0:I.data[0])??1;let g=[1,1,1,1],v=0;const O=this.vertexBufferLayout.fields.has(m.COLORFEATUREATTRIBUTE);O?v=r.attributes.get(m.COLORFEATUREATTRIBUTE).data[0]:r.attributes.has(m.COLOR)&&(g=r.attributes.get(m.COLOR).data);const S=st("enable-feature:objectAndLayerId-rendering")?r.objectAndLayerIdColor:null,_=this.vertexBufferLayout.fields.has(m.OPACITYFEATUREATTRIBUTE),b=_?r.attributes.get(m.OPACITYFEATUREATTRIBUTE).data[0]:0,C=new Float32Array(s.buffer),x=st("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,$=this.vertexBufferLayout.stride/4;let w=a*$;const V=w;let U=0;const P=p?(J,ae,be)=>U=p[be]:(J,ae,be)=>U+=Oi(J,ae),se=st("enable-feature:objectAndLayerId-rendering"),j=(J,ae,be,Ye,Ct,wo,Oo)=>{if(C[w++]=ae[0],C[w++]=ae[1],C[w++]=ae[2],C[w++]=J[0],C[w++]=J[1],C[w++]=J[2],C[w++]=be[0],C[w++]=be[1],C[w++]=be[2],C[w++]=Ye,C[w++]=Oo,C[w++]=Ct,C[w++]=f,O)C[w++]=v;else{const Ii=Math.min(4*wo,g.length-4);C[w++]=g[Ii],C[w++]=g[Ii+1],C[w++]=g[Ii+2],C[w++]=g[Ii+3]}_&&(C[w++]=b),se&&(S!=null&&(x[4*w]=S[0],x[4*w+1]=S[1],x[4*w+2]=S[2],x[4*w+3]=S[3]),w++)};w+=$,Z(o,l.data[0],l.data[1],l.data[2]),e&&ce(o,o,e);const qe=this._isClosed(r);if(qe){const J=l.data.length-3;Z(n,l.data[J],l.data[J+1],l.data[J+2]),e&&ce(n,n,e)}else Z(c,l.data[3],l.data[4],l.data[5]),e&&ce(c,c,e),j(o,o,c,1,Se.LEFT_CAP_START,0,0),j(o,o,c,1,Se.RIGHT_CAP_START,0,0),H(n,o),H(o,c);const ti=qe?0:1,ke=qe?d:d-1;for(let J=ti;J<ke;J++){const ae=(J+1)%d*3;Z(c,l.data[ae],l.data[ae+1],l.data[ae+2]),e&&ce(c,c,e),P(n,o,J),j(n,o,c,0,Se.LEFT_JOIN_END,J,U),j(n,o,c,0,Se.RIGHT_JOIN_END,J,U);const be=this.numJoinSubdivisions;for(let Ye=0;Ye<be;++Ye){const Ct=(Ye+1)/(be+1);j(n,o,c,Ct,Se.LEFT_JOIN_END,J,U),j(n,o,c,Ct,Se.RIGHT_JOIN_END,J,U)}j(n,o,c,1,Se.LEFT_JOIN_START,J,U),j(n,o,c,1,Se.RIGHT_JOIN_START,J,U),H(n,o),H(o,c)}qe?(Z(c,l.data[3],l.data[4],l.data[5]),e&&ce(c,c,e),U=P(n,o,ke),j(n,o,c,0,Se.LEFT_JOIN_END,ti,U),j(n,o,c,0,Se.RIGHT_JOIN_END,ti,U)):(U=P(n,o,ke),j(n,o,o,0,Se.LEFT_CAP_END,ke,U),j(n,o,o,0,Se.RIGHT_CAP_END,ke,U)),Pr(C,V+$,C,V,$),w=Pr(C,w-$,C,w,$),this._parameters.wireframe&&this._addWireframeVertices(s,V,w,$)}_addWireframeVertices(e,i,r,s){const a=new Float32Array(e.buffer,r*Float32Array.BYTES_PER_ELEMENT),n=new Float32Array(e.buffer,i*Float32Array.BYTES_PER_ELEMENT,r-i);let o=0;const c=l=>o=Pr(n,l,a,o,s);for(let l=0;l<n.length-1;l+=2*s)c(l),c(l+2*s),c(l+1*s),c(l+2*s),c(l+1*s),c(l+3*s)}};function Pr(t,e,i,r,s){for(let a=0;a<s;a++)i[r++]=t[e++];return r}function Yn(t,e){return t.isClosed?e.get(m.POSITION).indices.length>2:!1}function Wh(t){return t.anchor===vi.Tip&&t.hideOnShortSegments&&t.placement==="begin-end"&&t.worldSpace}const _e=D(),ye=D(),je=D(),dt=D(),qh=D(),ut=mt(),pt=mt(),Da=D(),Pa=D(),Ia=Dn(),kh=Dn(),Yh=D(),Jh=D(),Xh=D(),si=[mt(),mt(),mt(),mt()],Je=[D(),D(),D(),D()],Ir=Ti(),Mr=Ti(),Lr=Ti(),Nr=Ti();let Zh=class{constructor(e){this._originSR=e,this._rootOriginId="root/"+gn(),this._origins=new Map,this._objects=new Map,this._gridSize=5e5}getOrigin(e){const i=this._origins.get(this._rootOriginId);if(i==null){const h=rs(e[0]+Math.random()-.5,e[1]+Math.random()-.5,e[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,h),h}const r=this._gridSize,s=Math.round(e[0]/r),a=Math.round(e[1]/r),n=Math.round(e[2]/r),o=`${s}/${a}/${n}`;let c=this._origins.get(o);const l=.5*r;if(le(oe,e,i.vec3),oe[0]=Math.abs(oe[0]),oe[1]=Math.abs(oe[1]),oe[2]=Math.abs(oe[2]),oe[0]<l&&oe[1]<l&&oe[2]<l){if(c){const h=Math.max(...oe);if(le(oe,e,c.vec3),oe[0]=Math.abs(oe[0]),oe[1]=Math.abs(oe[1]),oe[2]=Math.abs(oe[2]),Math.max(...oe)<h)return c}return i}return c||(c=rs(s*r,a*r,n*r,o),this._origins.set(o,c)),c}_drawOriginBox(e,i=fi(1,1,0,1)){const r=window.view,s=r._stage,a=i.toString();if(!this._objects.has(a)){this._material=new Vh({width:2,color:i}),s.add(this._material);const f=new Hc(s,{pickable:!1}),g=new jc({castShadow:!1});s.add(g),f.add(g),this._objects.set(a,g)}const n=this._objects.get(a),o=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],c=o.length,l=new Array(3*c),h=new Array,d=.5*this._gridSize;for(let f=0;f<c;f++)l[3*f]=e[0]+(1&o[f]?d:-d),l[3*f+1]=e[1]+(2&o[f]?d:-d),l[3*f+2]=e[2]+(4&o[f]?d:-d),f>0&&h.push(f-1,f);lr(l,this._originSR,0,l,r.renderSpatialReference,0,c);const p=new Ae(this._material,[[m.POSITION,new F(l,h,3,!0)]],null,Kt.Line);s.add(p),n.addGeometry(p)}get test(){}};const oe=D();var yi;(function(t){t[t.Occluded=0]="Occluded",t[t.NotOccluded=1]="NotOccluded",t[t.Both=2]="Both",t[t.COUNT=3]="COUNT"})(yi||(yi={}));function bf(t){t.include(Pl),t.uniforms.add(new ei("geometryDepthTexture",(e,i)=>{var r;return(r=i.multipassGeometry.depth)==null?void 0:r.attachment})),t.code.add(y`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos);
return (elementDepth < (geometryDepth - 1.0));
}`)}let Qh=class{},Kh=class{constructor(e,i){this.shadowMap=e,this.slicePlane=i,this.slot=G.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this.transparencyPassType=Q.NONE,this.alignPixelEnabled=!1,this.decorations=bc.ON,this.overlayStretch=1,this.viewshedEnabled=!1,this._camera=new wr,this._inverseViewport=Y(),this.oldLighting=new Tr,this.newLighting=new Tr,this._fadedLighting=new Tr,this._lighting=this.newLighting,this.ssr=new ed,this.multipassEnabled=!1,this.multipassTerrain=new Il,this.multipassGeometry=new Qh,this.hudRenderStyle=yi.Occluded,this.cloudsFade=new nh,this.shadowHighlightsVisible=!1}get camera(){return this._camera}set camera(e){this._camera=e,this._inverseViewport[0]=1/e.fullViewport[2],this._inverseViewport[1]=1/e.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(e){const{oldLighting:i,newLighting:r}=this;e>=1?this._lighting=r:(this._fadedLighting.lerpLighting(i,r,e),this._lighting=this._fadedLighting)}},ed=class{constructor(){this.fadeFactor=1,this.reprojectionMatrix=B()}},td=class{constructor(e,i,r=null){this.rctx=e,this.sliceHelper=r,this.lastFrameCamera=new wr,this.output=E.Color,this.renderOccludedMask=ds,this.bindParameters=new Kh(i,r!=null?r.plane:null),this.bindParameters.alignPixelEnabled=!0}};const ds=$e.Occlude|$e.OccludeAndTransparent|$e.OccludeAndTransparentStencil;let di=class extends wr{constructor(){super(...arguments),this._projectionMatrix=B()}get projectionMatrix(){return this._projectionMatrix}};u([R()],di.prototype,"_projectionMatrix",void 0),u([R({readOnly:!0})],di.prototype,"projectionMatrix",null),di=u([We("esri.views.3d.webgl-engine.lib.CascadeCamera")],di);var us;(function(t){t[t.Highlight=0]="Highlight",t[t.ExcludeHighlight=1]="ExcludeHighlight"})(us||(us={}));let Hi=class{constructor(){this.camera=new di,this.lightMat=B()}},id=class{constructor(){this.maxNumCascadesHighQuality=4,this.maxNumCascadesLowQuality=4,this.textureSizeModHighQuality=1.3,this.textureSizeModLowQuality=.9,this.splitSchemeLambda=0}},rd=class{constructor(e,i){this._fbos=e,this._viewingMode=i,this._enabled=!1,this._snapshots=new Array,this._textureHeight=0,this._numCascades=1,this.settings=new id,this._projectionView=B(),this._projectionViewInverse=B(),this._modelViewLight=B(),this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=Ne(),this._cascades=[new Hi,new Hi,new Hi,new Hi],this._lastOrigin=null,this._maxTextureWidth=Math.min(st("esri-mobile")?4096:16384,e.rctx.parameters.maxTextureSize)}dispose(){this.enabled=!1,this.disposeOffscreenBuffers()}get depthTexture(){var e;return(e=this._handle)==null?void 0:e.getTexture()}get _textureWidth(){return this._textureHeight*this._numCascades}get numCascades(){return this._numCascades}get cascadeDistances(){return or(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}disposeOffscreenBuffers(){this._handle=nr(this._handle),this._discardSnapshots()}set maxCascades(e){this.settings.maxNumCascadesHighQuality=Yt(Math.floor(e),1,4)}get maxCascades(){return this.settings.maxNumCascadesHighQuality}set enabled(e){this._enabled=e,e||this.disposeOffscreenBuffers()}get enabled(){return this._enabled}get ready(){return this._enabled&&this.depthTexture!=null}get cascades(){for(let e=0;e<this._numCascades;++e)jr[e]=this._cascades[e];return jr.length=this._numCascades,jr}start(e,i,r,s,a){ve(this.enabled);const{near:n,far:o}=cd(r);this._computeCascadeDistances(n,o,s),this._textureHeight=this._computeTextureHeight(e,a,s),this._setupMatrices(e,i);const{viewMatrix:c,projectionMatrix:l}=e;for(let h=0;h<this._numCascades;++h)this._constructCascade(h,l,c,i);this._lastOrigin=null,this.clear()}finish(){var e;ve(this.enabled),(e=this._handle)==null||e.detachDepth()}getShadowMapMatrices(e){if(!this._lastOrigin||!Vt(e,this._lastOrigin)){this._lastOrigin=this._lastOrigin||D(),H(this._lastOrigin,e);for(let i=0;i<this._numCascades;++i){Ys(za,this._cascades[i].lightMat,e);for(let r=0;r<16;++r)Ua[16*i+r]=za[r]}}return Ua}moveSnapshot(e){var i,r;ve(this.enabled),(i=this._handle)==null||i.detachDepth(),(r=this._snapshots[e])==null||r.release(),this._snapshots[e]=this._handle,this._handle=null,this.clear()}copySnapshot(e){var c,l,h,d;const i=(l=(c=this._handle)==null?void 0:c.getTexture())==null?void 0:l.descriptor;if(!this.enabled||!i)return;(h=this._snapshots[e])==null||h.release();const{width:r,height:s}=i,a=e===us.Highlight?"shadow highlight snapshot":"shadow no highlight snapshot";this._snapshots[e]=this._fbos.acquire(r,s,a,cr.RGBA4);const n=this._fbos.rctx;this._bindFbo();const o=n.bindTexture((d=this._snapshots[e])==null?void 0:d.getTexture(),ts.TEXTURE_UNIT_FOR_UPDATES);n.gl.copyTexSubImage2D(hc.TEXTURE_2D,0,0,0,0,0,r,s),n.bindTexture(o,ts.TEXTURE_UNIT_FOR_UPDATES)}getSnapshot(e){var i;return this.enabled?(i=this._snapshots[e])==null?void 0:i.getTexture():null}clear(){const e=this._fbos.rctx;this._ensureFbo(),this._bindFbo(),e.setClearColor(1,1,1,1),e.clear(dr.COLOR_BUFFER_BIT|dr.DEPTH_BUFFER_BIT)}_computeTextureHeight(e,i,r){const s=Math.min(window.devicePixelRatio,i)/e.pixelRatio,a=r?this.settings.textureSizeModHighQuality:this.settings.textureSizeModLowQuality,n=Ml(Math.floor(Math.max(e.fullWidth,e.fullHeight)*s*a)),o=Math.min(this._maxTextureWidth,this._numCascades*n);return Ll(o/this._numCascades)}_ensureFbo(){var e,i,r,s,a;((i=(e=this._handle)==null?void 0:e.fbo)==null?void 0:i.width)===this._textureWidth&&((r=this._handle)==null?void 0:r.fbo.height)===this._textureHeight||((s=this._handle)==null||s.release(),this._handle=this._fbos.acquire(this._textureWidth,this._textureHeight,"shadow map",cr.RGBA4)),(a=this._handle)==null||a.acquireDepth(Nl.DEPTH16_BUFFER)}_discardSnapshot(e){this._snapshots[e]=nr(this._snapshots[e])}_discardSnapshots(){for(let e=0;e<this._snapshots.length;++e)this._discardSnapshot(e);this._snapshots.length=0}_bindFbo(){var i;const e=this._fbos.rctx;e.unbindTexture(this.depthTexture),e.bindFramebuffer((i=this._handle)==null?void 0:i.fbo)}_constructCascade(e,i,r,s){const a=this._cascades[e],n=-this._cascadeDistances[e],o=-this._cascadeDistances[e+1],c=(i[10]*n+i[14])/Math.abs(i[11]*n+i[15]),l=(i[10]*o+i[14])/Math.abs(i[11]*o+i[15]);ve(c<l);for(let f=0;f<8;++f){or(Ma,f%4==0||f%4==3?-1:1,f%4==0||f%4==1?-1:1,f<4?c:l,1);const g=Ee[f];Ht(g,Ma,this._projectionViewInverse),g[0]/=g[3],g[1]/=g[3],g[2]/=g[3]}Mo(Fr,Ee[0]),a.camera.viewMatrix=Ys(sd,this._modelViewLight,Fr);for(let f=0;f<8;++f)ce(Ee[f],Ee[f],a.camera.viewMatrix);let h=Ee[0][2],d=Ee[0][2];for(let f=1;f<8;++f)h=Math.min(h,Ee[f][2]),d=Math.max(d,Ee[f][2]);h-=200,d+=200,a.camera.near=-d,a.camera.far=-h,ld(r,s,h,d,a.camera),nt(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const p=this._textureHeight;a.camera.viewport=[e*p,0,p,p]}_setupMatrices(e,i){nt(this._projectionView,e.projectionMatrix,e.viewMatrix),kt(this._projectionViewInverse,this._projectionView);const r=this._viewingMode===wt.Global?e.eye:Z(Fr,0,0,1);fn(this._modelViewLight,[0,0,0],[-i[0],-i[1],-i[2]],r)}_computeCascadeDistances(e,i,r){const s=r?this.settings.maxNumCascadesHighQuality:this.settings.maxNumCascadesLowQuality;this._numCascades=Math.min(1+Math.floor(mc(i/e,4)),s);const a=(i-e)/this._numCascades,n=(i/e)**(1/this._numCascades);let o=e,c=e;for(let l=0;l<this._numCascades+1;++l)this._cascadeDistances[l]=li(o,c,this.settings.splitSchemeLambda),o*=n,c+=a}get test(){}};const sd=B(),Ma=Ne(),Ee=[];for(let t=0;t<8;++t)Ee.push(Ne());const La=Y(),Na=Y(),ad=Y(),Fa=Y(),ja=Y(),Fr=D(),jr=[],za=B(),Ua=Ue.concat(Ue,Ue,Ue,Ue),Te=Y(),Pt=Y(),ft=[Y(),Y(),Y(),Y()],ee=Y(),zr=Y(),Qe=Y(),ai=Y(),It=Y(),Mt=Y(),Gi=Y();function nd(t,e,i,r,s,a,n,o){lt(Te,0,0);for(let x=0;x<4;++x)ht(Te,Te,t[x]);zt(Te,Te,.25),lt(Pt,0,0);for(let x=4;x<8;++x)ht(Pt,Pt,t[x]);zt(Pt,Pt,.25),ii(ft[0],t[4],t[5],.5),ii(ft[1],t[5],t[6],.5),ii(ft[2],t[6],t[7],.5),ii(ft[3],t[7],t[4],.5);let c=0,l=Js(ft[0],Te);for(let x=1;x<4;++x){const $=Js(ft[x],Te);$<l&&(l=$,c=x)}Ut(ee,ft[c],t[c+4]);const h=ee[0];let d,p;ee[0]=-ee[1],ee[1]=h,Ut(zr,Pt,Te),pe(zr,ee)<0&&No(ee,ee),ii(ee,ee,zr,i),Xs(ee,ee),d=p=pe(Ut(Qe,t[0],Te),ee);for(let x=1;x<8;++x){const $=pe(Ut(Qe,t[x],Te),ee);$<d?d=$:$>p&&(p=$)}mr(r,Te),zt(Qe,ee,d-e),ht(r,r,Qe);let f=-1,g=1,v=0,O=0;for(let x=0;x<8;++x){Ut(ai,t[x],r),Xs(ai,ai);const $=ee[0]*ai[1]-ee[1]*ai[0];$>0?$>f&&(f=$,v=x):$<g&&(g=$,O=x)}At(f>0,"leftArea"),At(g<0,"rightArea"),zt(It,ee,d),ht(It,It,Te),zt(Mt,ee,p),ht(Mt,Mt,Te),Gi[0]=-ee[1],Gi[1]=ee[0];const S=Ni(r,t[O],Mt,ht(Qe,Mt,Gi),1,s),_=Ni(r,t[v],Mt,Qe,1,a),b=Ni(r,t[v],It,ht(Qe,It,Gi),1,n),C=Ni(r,t[O],It,Qe,1,o);At(S,"rayRay"),At(_,"rayRay"),At(b,"rayRay"),At(C,"rayRay")}function N(t,e){return 3*e+t}const Va=Y();function Oe(t,e){return lt(Va,t[e],t[e+3]),Va}const we=Y(),A=ys();function od(t,e,i,r,s){Ut(we,i,r),zt(we,we,.5),A[0]=we[0],A[1]=we[1],A[2]=0,A[3]=we[1],A[4]=-we[0],A[5]=0,A[6]=we[0]*we[0]+we[1]*we[1],A[7]=we[0]*we[1]-we[1]*we[0],A[8]=1,A[N(0,2)]=-pe(Oe(A,0),t),A[N(1,2)]=-pe(Oe(A,1),t);let a=pe(Oe(A,0),i)+A[N(0,2)],n=pe(Oe(A,1),i)+A[N(1,2)],o=pe(Oe(A,0),r)+A[N(0,2)],c=pe(Oe(A,1),r)+A[N(1,2)];a=-(a+o)/(n+c),A[N(0,0)]+=A[N(1,0)]*a,A[N(0,1)]+=A[N(1,1)]*a,A[N(0,2)]+=A[N(1,2)]*a,a=1/(pe(Oe(A,0),i)+A[N(0,2)]),n=1/(pe(Oe(A,1),i)+A[N(1,2)]),A[N(0,0)]*=a,A[N(0,1)]*=a,A[N(0,2)]*=a,A[N(1,0)]*=n,A[N(1,1)]*=n,A[N(1,2)]*=n,A[N(2,0)]=A[N(1,0)],A[N(2,1)]=A[N(1,1)],A[N(2,2)]=A[N(1,2)],A[N(1,2)]+=1,a=pe(Oe(A,1),e)+A[N(1,2)],n=pe(Oe(A,2),e)+A[N(2,2)],o=pe(Oe(A,1),i)+A[N(1,2)],c=pe(Oe(A,2),i)+A[N(2,2)],a=-.5*(a/n+o/c),A[N(1,0)]+=A[N(2,0)]*a,A[N(1,1)]+=A[N(2,1)]*a,A[N(1,2)]+=A[N(2,2)]*a,a=pe(Oe(A,1),e)+A[N(1,2)],n=pe(Oe(A,2),e)+A[N(2,2)],o=-n/a,A[N(1,0)]*=o,A[N(1,1)]*=o,A[N(1,2)]*=o,s[0]=A[0],s[1]=A[1],s[2]=0,s[3]=A[2],s[4]=A[3],s[5]=A[4],s[6]=0,s[7]=A[5],s[8]=0,s[9]=0,s[10]=1,s[11]=0,s[12]=A[6],s[13]=A[7],s[14]=0,s[15]=A[8]}function ld(t,e,i,r,s){const a=1/Ee[0][3],n=1/Ee[4][3];ve(a<n);let o=a+Math.sqrt(a*n);const c=Math.sin(Lo(t[2]*e[0]+t[6]*e[1]+t[10]*e[2]));o/=c,nd(Ee,o,c,La,Na,ad,Fa,ja),od(La,Na,Fa,ja,s.projectionMatrix),s.projectionMatrix[10]=2/(i-r),s.projectionMatrix[14]=-(i+r)/(i-r)}function cd(t){let{near:e,far:i}=t;return e<2&&(e=2),i<2&&(i=2),e>=i&&(e=2,i=4),{near:e,far:i}}var ct,bt;(function(t){t[t.OBJECT=0]="OBJECT",t[t.HUD=1]="HUD",t[t.TERRAIN=2]="TERRAIN",t[t.OVERLAY=3]="OVERLAY",t[t.I3S=4]="I3S",t[t.PCL=5]="PCL",t[t.LOD=6]="LOD",t[t.VOXEL=7]="VOXEL",t[t.TILES3D=8]="TILES3D"})(ct||(ct={}));let hd=class{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.filteredLayerUids=[],this.store=bt.ALL,this.normalRequired=!0}};(function(t){t[t.MIN=0]="MIN",t[t.MINMAX=1]="MINMAX",t[t.ALL=2]="ALL"})(bt||(bt={}));let dd=class{constructor(e,i,r){this.object=e,this.geometryId=i,this.triangleNr=r}},ud=class extends dd{constructor(e,i,r,s){super(e,i,r),this.center=s!=null?Xr(s):null}},pd=class{constructor(e){this.layerUid=e}},fd=class extends pd{constructor(e,i){super(e),this.graphicUid=i}};function gd(t){return(t==null?void 0:t.dist)!=null}let md=class extends fd{constructor(e,i,r){super(e,i),this.triangleNr=r}};const Ha=1e-5;let vd=class{constructor(e){this.options=new hd,this._results=new _d,this.transform=new Fl,this.tolerance=Ha,this.verticalOffset=null,this._ray=tt(),this._rayEnd=D(),this._rayBeginTransformed=D(),this._rayEndTransformed=D(),this.viewingMode=e??wt.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(e,i,r){this.resetWithRay(Fo(e,i,this._ray),r)}resetWithRay(e,i){this.camera=i,e!==this._ray&&Zr(e,this._ray),this.options.verticalOffset!==0?this.viewingMode===wt.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,K(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(e=null,i,r,s,a){var o;this.point=i,this.filterPredicate=s,this.tolerance=r??Ha;const n=sa(this.verticalOffset);if(e&&e.length>0){const c=a?l=>{a(l)&&this.intersectObject(l)}:l=>{this.intersectObject(l)};for(const l of e){const h=(o=l.getSpatialQueryAccelerator)==null?void 0:o.call(l);h!=null?(n!=null?h.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,c,n):h.forEachAlongRay(this._ray.origin,this._ray.direction,c),this.options.selectionMode&&this.options.hud&&h.forEachDegenerateObject(c)):l.objects.forAll(d=>c(d))}}this.sortResults()}intersectObject(e){const i=e.geometries;if(!i)return;const r=e.effectiveTransformation,s=sa(this.verticalOffset);for(const a of i){if(!a.visible)continue;const{material:n,id:o}=a;this.transform.setAndInvalidateLazyTransforms(r,a.transformation),ce(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),ce(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const c=this.transform.transform;s!=null&&(s.objectTransform=this.transform),n.intersect(a,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(l,h,d,p,f,g)=>{if(l>=0){if(this.filterPredicate!=null&&!this.filterPredicate(this._ray.origin,this._rayEnd,l))return;const v=p?this._results.hud:this._results,O=p?S=>{const _=new ud(e,o,d,g);S.set(ct.HUD,_,l,h,Ue,f)}:S=>S.set(ct.OBJECT,{object:e,geometryId:o,triangleNr:d},l,h,c,f);if((v.min.drapedLayerOrder==null||f>=v.min.drapedLayerOrder)&&(v.min.dist==null||l<v.min.dist)&&O(v.min),this.options.store!==bt.MIN&&(v.max.drapedLayerOrder==null||f<v.max.drapedLayerOrder)&&(v.max.dist==null||l>v.max.dist)&&O(v.max),this.options.store===bt.ALL)if(p){const S=new ps(this._ray);O(S),this._results.hud.all.push(S)}else{const S=new Jt(this._ray);O(S),this._results.all.push(S)}}})}}sortResults(e=this._results.all){e.sort((i,r)=>i.dist!==r.dist?(i.dist??0)-(r.dist??0):i.drapedLayerOrder!==r.drapedLayerOrder?Ga(i.drapedLayerOrder,r.drapedLayerOrder):Ga(i.drapedLayerGraphicOrder,r.drapedLayerGraphicOrder))}};function Ga(t,e){return(e??-Number.MAX_VALUE)-(t??-Number.MAX_VALUE)}function zf(t){return new vd(t)}let _d=class{constructor(){this.min=new Jt(tt()),this.max=new Jt(tt()),this.hud={min:new ps(tt()),max:new ps(tt()),all:new Array},this.ground=new Jt(tt()),this.all=[]}init(e){this.min.init(e),this.max.init(e),this.ground.init(e),this.all.length=0,this.hud.min.init(e),this.hud.max.init(e),this.hud.all.length=0}},Jt=class{get ray(){return this._ray}get distanceInRenderSpace(){return this.dist!=null?(k(Bi,this.ray.direction,this.dist),He(Bi)):null}getIntersectionPoint(e){return!!gd(this)&&(k(Bi,this.ray.direction,this.dist),K(e,this.ray.origin,Bi),!0)}getTransformedNormal(e){return H(ni,this.normal),ni[3]=0,Ht(ni,ni,this.transformation),H(e,ni),te(e,e)}constructor(e){this.intersector=ct.OBJECT,this.normal=D(),this.transformation=B(),this._ray=tt(),this.init(e)}init(e){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=ct.OBJECT,Zr(e,this._ray)}set(e,i,r,s,a,n,o){this.intersector=e,this.dist=r,H(this.normal,s??jo),Ze(this.transformation,a??Ue),this.target=i,this.drapedLayerOrder=n,this.drapedLayerGraphicOrder=o}copy(e){Zr(e.ray,this._ray),this.intersector=e.intersector,this.dist=e.dist,this.target=e.target,this.drapedLayerOrder=e.drapedLayerOrder,this.drapedLayerGraphicOrder=e.drapedLayerGraphicOrder,H(this.normal,e.normal),Ze(this.transformation,e.transformation)}},ps=class extends Jt{constructor(){super(...arguments),this.intersector=ct.HUD}};function yd(t){return new Jt(t)}const Bi=D(),ni=Ne();let wd=class{constructor(e,i){this._material=e,this._repository=i,this._map=new Map}dispose(){this._map.forEach((e,i)=>{e!=null&&this._repository.release(this._material,i)})}load(e,i,r){const s=this._material.produces.get(i);if(!(s!=null&&s(r)))return null;this._map.has(r)||this._map.set(r,this._repository.acquire(this._material,i,r));const a=this._map.get(r);if(a!=null){if(a.ensureResources(e)===xc.LOADED)return a;this._repository.requestRender()}return null}},Od=class extends jl{constructor(e=D()){super(),this.origin=e,this.slicePlaneLocalOrigin=this.origin}},Fs=class{constructor(e=0,i=0){this.from=e,this.to=i}get numElements(){return this.to-this.from}};function Ba(t){const e=new Map;t.forAll(r=>e.set(r.from,r));let i=!0;for(;i;){i=!1;for(let r=0;r<t.length;++r){const s=t.data[r],a=e.get(s.to);if(!a)return;s.to=a.to,e.delete(a.from),t.removeUnordered(a),i=!0}}}let Wa=class extends Fs{constructor(e,i,r){super(i,r),this.geometry=e}get isVisible(){return this.geometry.visible}get hasHighlights(){return this.geometry.highlights!=null&&this.isVisible}get hasOccludees(){return this.geometry.occludees!=null}},Sd=class{constructor(){this.first=0,this.count=0}},bd=class{constructor(){this._numElements=0,this._instances=new Map,this.holes=new Ge({allocator:e=>e||new Fs,deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.drawCommandsDefault=Wi(),this.drawCommandsHighlight=Wi(),this.drawCommandsOccludees=Wi(),this.drawCommandsShadowHighlightRest=Wi()}get numElements(){return this._numElements}get instances(){return this._instances}addInstance(e,i){this.deleteInstance(e),this._instances.set(e,i),this._numElements+=i.numElements}deleteInstance(e){const i=this._instances.get(e);i&&(this._numElements-=i.numElements,this._instances.delete(e))}updateInstance(e,i,r){const s=this._instances.get(e);s&&(this._numElements-=s.numElements,s.from=i,s.to=r,this._numElements+=s.numElements)}updateDrawState(e){e.isVisible?(e.hasHighlights&&(this.hasHighlights=!0),e.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(e){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlight.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,this._instances.size===0)return;if(!this.needsMultipleCommands()){const r=this.drawCommandsDefault.pushNew(),s=this.holes.front();return this.vao!=null&&this.holes.length===1&&s.to===Math.floor(this.vao.byteSize/e)?(r.first=0,void(r.count=s.from)):(r.first=1/0,r.count=0,this._instances.forEach(a=>{r.first=Math.min(r.first,a.from),r.count=Math.max(r.count,a.to)}),void(r.count-=r.first))}const i=Array.from(this._instances.values()).sort((r,s)=>r.from===s.from?r.to-s.to:r.from-s.from);for(const r of i)r.isVisible&&(qa(r.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,r),qa(r.hasHighlights?this.drawCommandsHighlight:this.drawCommandsShadowHighlightRest,r))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}};function xd(t){return t.vao!=null}function Wi(){return new Ge({allocator:t=>t||new Sd,deallocator:t=>t})}function qa(t,e){const i=t.back();if(i==null){const r=t.pushNew();return r.first=e.from,void(r.count=e.numElements)}if(Td(i,e)){const r=e.from-i.first+e.numElements;i.count=r}else{const r=t.pushNew();r.first=e.from,r.count=e.numElements}}function Td(t,e){return t.first+t.count>=e.from}let Cd=class{constructor(e){this.origin=e,this.buffers=new Array}dispose(){this.buffers.forEach(e=>e.vao.dispose()),this.buffers.length=0}findBuffer(e){return this.buffers.find(i=>i.instances.has(e))}},Ad=class{constructor(e,i){this._cache=e(i,(r,s,a)=>{switch(s){case va.ALL:return r.forEach(n=>n.dispose()),0;case va.SOME:{const n=r.shift();return n&&(a-=Math.round(n.usedMemory),n.dispose()),a}}})}hitrate(){return this._cache.hitRate}destroy(){this._cache.destroy()}clear(){this._cache.clear()}getSize(e){return this._cache.getSize(e)}pop(e){const i=this._cache.peek(e);if(!i)return;const r=i.pop();if(i.length>0){if(r){const s=this._cache.getSize(e)-Math.round(r.usedMemory);this._cache.updateSize(e,i,s)}}else this._cache.pop(e);return r}put(e,i,r=Lc){const s=this._cache.peek(e);if(!s)return void this._cache.put(e,[i],i.usedMemory,r);s.push(i);const a=this._cache.getSize(e)+Math.round(i.usedMemory);this._cache.updateSize(e,s,a)}},Rd=class{constructor(e,i,r){this._rctx=e,this._locations=i,this._layout=r,this._cache=new Ad(e.newCache,"VAOCache")}dispose(){this._cache.destroy()}newVao(e){const i=e.toString();let r=this._cache.pop(i);return r||(r=new qc(this._rctx,this._locations,{geometry:this._layout},{geometry:Fc.createVertex(this._rctx,dc.STATIC_DRAW)}),r.vertexBuffers.geometry.setSize(e),r)}deleteVao(e){if(e==null)return;const i=e.byteSize.toString();this._cache.put(i,e)}},er=class extends Wc{constructor(e){super(e),this._vaoCache=null,this._glMaterials=null,this._bufferWriter=null,this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._produces=new Map,this.drapedPriority=0}destroy(){this._glMaterials=gi(this._glMaterials),this._dataByOrigin.forEach(e=>e.dispose()),this._dataByOrigin.clear(),this._vaoCache=gi(this._vaoCache)}initialize(){this.material.produces.forEach((e,i)=>{this._produces.set(i,r=>!(this._dataByOrigin.size===0||!(r!==E.Highlight&&r!==E.ShadowHighlight||this._hasHighlights))&&e(r))})}get produces(){return this._produces}initializeRenderContext(e,i){const{rctx:r}=e.renderContext;this._glMaterials=new wd(this.material,i??e.materials),this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=new Rd(r,this.material.vertexAttributeLocations,Mc(this._bufferWriter.vertexBufferLayout))}uninitializeRenderContext(){}get hasOccludees(){return this._hasOccludees}get isDecoration(){return this.material.parameters.isDecoration}queryRenderOccludedState(e){return this.material.queryRenderOccludedState(e)}get materialReference(){return this.material}get numGeometries(){let e=0;return this._dataByOrigin.forEach(i=>e+=i.buffers.reduce((r,s)=>r+s.instances.size,0)),e}get usedMemory(){let e=0;return this._dataByOrigin.forEach(i=>e+=i.buffers.reduce((r,s)=>r+s.vao.usedMemory,0)),e}forEachGeometry(e){this._dataByOrigin.forEach(i=>i.buffers.forEach(r=>r.instances.forEach(s=>e(s.geometry))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){const i=this._bufferWriter;if(i===null)return;const r=i.vertexBufferLayout.stride/4;for(const s of e){const a=s.renderGeometry,n=this._dataByOrigin.get(a.localOrigin.id),o=n==null?void 0:n.findBuffer(a.id);if(o==null)return;const c=o.instances.get(a.id);if(s.updateType&(Ve.GEOMETRY|Ve.TRANSFORMATION)){const l=Yi(i.elementCount(c.geometry.geometry)*r),h=i.vertexBufferLayout.createView(l.buffer);this._writeGeometry(a,h,0),o.vao.vertexBuffers.geometry.setSubData(l,c.from*r,0,c.numElements*r)}s.updateType&(Ve.HIGHLIGHT|Ve.OCCLUDEE|Ve.VISIBILITY)&&(o.drawCommandsDirty=!0)}}_computeDeltas(e,i){const r=new Ms;for(const s of e){const a=s.localOrigin;if(a==null)continue;let n=r.get(a.id,null);n==null&&(n=new ka(a.vec3),r.set(a.id,null,n)),n.changes.push(s)}for(const s of i){const a=s.localOrigin;if(a==null)continue;const n=this._dataByOrigin.get(a.id),o=n==null?void 0:n.findBuffer(s.id);if(o==null)continue;let c=r.get(a.id,o);c==null&&(c=new ka(a.vec3),r.set(a.id,o,c)),c.changes.push(s)}return r}_addAndRemoveGeometries(e,i){if(this._bufferWriter===null||this._vaoCache===null)return;const{_bufferWriter:r,_dataByOrigin:s}=this,a=r.vertexBufferLayout.stride/4,n=this._computeDeltas(e,i);n.forEach((o,c)=>{const l=o.get(null),h=l!=null?l.changes:[];n.delete(c,null);let d=s.get(c);if(o.forEach((p,f)=>{if(n.delete(c,f),f==null)return void ve(!1,"No VAO for removed geometries");if(f.instances.size===p.changes.length)return this._vaoCache.deleteVao(f.vao),Zs(d.buffers,f),void(d.buffers.length===0&&h.length===0&&s.delete(c));const g=f.numElements,v=f.vao.byteSize/4,O=h.reduce((C,x)=>C+r.elementCount(x.geometry),0),S=p.changes.reduce((C,x)=>C+r.elementCount(x.geometry),0),_=Math.min((g+O-S)*a,ki),b=_>v;_>gr&&_<v/2?(p.changes.forEach(({id:C})=>f.deleteInstance(C)),f.instances.forEach(({geometry:C})=>h.push(C)),this._vaoCache.deleteVao(f.vao),Zs(d.buffers,f)):b?this._applyAndRebuild(f,h,p):this._applyRemoves(f,p)}),h.length>0)for(d==null&&(d=new Cd(l.origin),s.set(c,d)),d.buffers.forEach(p=>this._applyAdds(p,h));h.length>0;)d.buffers.push(this._applyAndRebuild(new bd,h,null))})}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach(e=>{e.buffers.forEach(i=>{i.drawCommandsDirty&&(i.hasHiddenInstances=!1,i.hasHighlights=!1,i.hasOccludees=!1,it(i.instances,r=>(i.updateDrawState(r),i.hasHiddenInstances&&i.hasHighlights&&i.hasOccludees)),i.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||i.hasHighlights,this._hasOccludees=this._hasOccludees||i.hasOccludees})})}_applyAndRebuild(e,i,r){if(r!=null)for(const g of r.changes)e.deleteInstance(g.id);const s=this._bufferWriter,a=s.vertexBufferLayout.stride,n=a/4,o=Math.floor(ki/n);let c=e.numElements;for(;i.length>0;){const g=i.pop(),v=s.elementCount(g.geometry);if(c+v>o&&c>0){i.push(g);break}c+=v;const O=new Wa(g,0,0);ve(e.instances.get(g.id)==null),e.addInstance(g.id,O)}const l=c*n,h=Yi(l),d=s.vertexBufferLayout.createView(h.buffer);let p=0;e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,e.instances.forEach((g,v)=>{this._writeGeometry(g.geometry,d,p);const O=p;p+=s.elementCount(g.geometry.geometry),e.updateInstance(v,O,p),e.updateDrawState(g)}),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(Xa(l)),e.vao.vertexBuffers.geometry.setSubData(h,0,0,p*n),e.holes.clear();const f=e.holes.pushNew();return f.from=p,f.to=Math.floor(e.vao.byteSize/a),e.updateDrawCommands(a),e}_applyRemoves(e,i){if(i.changes.length===0||this._bufferWriter===null)return;for(const o of i.changes){const c=o.id,l=e.instances.get(c);if(!l)continue;e.deleteInstance(c);const h=ze.back();if(h){if(h.to===l.from){h.to=l.to;continue}if(h.from===l.to){h.from=l.from;continue}}const d=ze.pushNew();d.from=l.from,d.to=l.to}Ba(ze);const r=this._bufferWriter.vertexBufferLayout.stride/4,s=ze.reduce((o,c)=>Math.max(o,c.numElements),0)*r,a=Yi(s);a.fill(0,0,s);const n=e.vao.vertexBuffers.geometry;ze.forAll(o=>n.setSubData(a,o.from*r,0,o.numElements*r)),e.holes.pushArray(ze.data,ze.length),ze.forAll((o,c)=>ze.data[c]=null),ze.clear(),e.drawCommandsDirty=!0}_applyAdds(e,i){if(i.length===0||this._bufferWriter===null)return;if(!xd(e))return void this._applyAndRebuild(e,i,null);const r=this._bufferWriter,s=r.vertexBufferLayout.stride/4,a=e.numElements,n=i.reduce((S,_)=>S+r.elementCount(_.geometry),0),o=Math.min((a+n)*s,ki),c=4*o;if(e.vao.byteSize<Xa(ki-gr)&&c>e.vao.byteSize)return void this._applyAndRebuild(e,i,null);Ba(e.holes);const l=new Array;for(const S of i){const _=r.elementCount(S.geometry),b=Ed(e.holes,_);l.push(b)}const h=e.vao.vertexBuffers.geometry;let d=0,p=0,f=0;const g=Yi(o),v=r.vertexBufferLayout.createView(g.buffer);i.forEach((S,_)=>{const b=l[_];if(b==null)return;if(f!==b){const $=f-p;$>0&&h.setSubData(g,p*s,0,$*s),p=b,d=0}const C=r.elementCount(S.geometry);this._writeGeometry(S,v,d),d+=C,f=b+C;const x=new Wa(S,b,b+C);ve(e.instances.get(S.id)==null),e.addInstance(S.id,x),e.drawCommandsDirty=!0});const O=f-p;O>0&&h.setSubData(g,p*s,0,O*s),zo(i,(S,_)=>l[_]==null)}_writeGeometry(e,i,r){if(this._bufferWriter===null)return;const s=e.localOrigin.vec3;vc(Ya,-s[0],-s[1],-s[2]);const a=nt($d,Ya,e.transformation);kt(qi,a),pn(qi,qi),this._bufferWriter.write(a,qi,e.geometry,i,r)}updateAnimation(e){return this.material.update(e)}prepareTechnique(e){if(!this.material.shouldRender(e))return null;const{output:i,bindParameters:r}=e,s=this.material.produces.get(r.slot);if(!(s!=null&&s(i)))return null;const a=i===E.Highlight||i===E.ShadowHighlight;if(a&&!this._hasHighlights)return null;const n=i===E.ShadowExcludeHighlight,o=!(a||n);for(const c of this._dataByOrigin.values())for(const l of c.buffers){if(a&&!l.hasHighlights)continue;const h=(a?l.drawCommandsHighlight:n&&l.needsMultipleCommands()?l.drawCommandsShadowHighlightRest:l.drawCommandsDefault)||null,d=o&&l.drawCommandsOccludees||null;if(h!=null&&h.length||d!=null&&d.length){const p=this._glMaterials.load(e.rctx,r.slot,i),f=p!=null?p.beginSlot(r):null;if(f!=null)return f}}return null}renderNode(e,i){const{output:r,bindParameters:s}=e,a=r===E.Highlight||r===E.ShadowHighlight,n=r===E.ShadowExcludeHighlight,o=!(a||n),c=s.slot===G.OCCLUDER_MATERIAL,l=s.slot===G.TRANSPARENT_OCCLUDER_MATERIAL,h=e.rctx;h.runAppleAmdDriverHelper(),h.bindTechnique(i,s,this.material.parameters);for(const d of this._dataByOrigin.values())for(const p of d.buffers){if(a&&!p.hasHighlights)continue;const f=(a?p.drawCommandsHighlight:n&&p.needsMultipleCommands()?p.drawCommandsShadowHighlightRest:p.drawCommandsDefault)||null,g=o&&p.drawCommandsOccludees||null;(f!=null&&f.length||g!=null&&g.length)&&(i.program.bindDraw(new Od(d.origin),s,this.material.parameters),i.ensureAttributeLocations(p.vao),h.bindVAO(p.vao),f!=null&&f.length&&(h.setPipelineState(i.getPipeline(!1,c,l)),f.forAll(v=>h.drawArrays(i.primitiveType,v.first,v.count))),g!=null&&g.length&&(h.setPipelineState(i.getPipeline(!0,c,l)),g.forAll(v=>h.drawArrays(i.primitiveType,v.first,v.count))))}}get test(){}};u([R({constructOnly:!0})],er.prototype,"material",void 0),er=u([We("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")],er);let ka=class{constructor(e){this.origin=e,this.changes=new Array}};function Ed(t,e){let i;if(!t.some(s=>!(s.numElements<e)&&(i=s,!0)))return null;const r=i.from;return i.from+=e,i.from>=i.to&&t.removeUnordered(i),r}const Ya=B(),$d=B(),qi=B(),ze=new Ge({allocator:t=>t||new Fs,deallocator:null}),gr=65536,Ur=4*gr,Ja=1024,Jn=16777216,ki=Jn/4;let Vr=new Float32Array(gr);function Yi(t){return Vr.length<t&&(Vr=new Float32Array(t)),Vr}function Xa(t){const e=4*t;return e<=Ja?Ja:e<Ur?Uo(e):Math.max(Math.min(Math.ceil(1.5*e/Ur)*Ur,Jn),e)}let Re=class extends ms{constructor(e){super(e),this._pending=new Dd,this._changes=new th,this._materialRenderers=new Map,this._sortedMaterialRenderers=new Ge,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forEach(e=>e.destroy()),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear(),this._pending.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materials(){return this.rendererContext.materials}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccludedDraped(){return it(this._materialRenderers,e=>e.numGeometries!==0&&!e.queryRenderOccludedState($e.Occlude))}get isEmpty(){return!this.updating&&this._materialRenderers.size===0&&this._geometries.size===0}getMaterialRenderer(e){return this._materialRenderers.get(e)}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const e=sh(this._changes);let i=!1;return e.forEach((r,s)=>{let a=this.getMaterialRenderer(s);if(!a&&r.adds.length>0){const n=new er({material:s});n.initializeRenderContext(this.rendererContext.pluginContext,this._materials),a=n,this._materialRenderers.set(s,a),i=!0}a&&(a.modify(r),a.numGeometries===0&&(this._materialRenderers.delete(s),a.destroy(),i=!0))}),this._changes.clear(),i&&this._updateSortedMaterialRenderers(),this._hasHighlights=it(this._materialRenderers,r=>{const s=r.produces.get(G.DRAPED_MATERIAL);return!!s&&s(E.Highlight)}),this._hasWater=it(this._materialRenderers,r=>{const s=r.produces.get(G.DRAPED_WATER);return!!s&&s(E.Normal)}),this.notifyChange("updating"),!0}addGeometries(e,i){if(e.length===0)return;const r=this._validateRenderGeometries(e);for(const a of r)this._geometries.set(a.id,a);const s=this._pending.empty;for(const a of r)this._pending.adds.add(a);s&&this.notifyChange("updating"),i===fr.UPDATE&&this._notifyGraphicGeometryChanged(e)}removeGeometries(e,i){const r=this._pending.empty,s=this._pending.adds;for(const a of e)s.has(a)?(this._pending.removed.add(a),s.delete(a)):this._pending.removed.has(a)||this._pending.removes.add(a),this._geometries.delete(a.id);r&&!this._pending.empty&&this.notifyChange("updating"),i===fr.UPDATE&&this._notifyGraphicGeometryChanged(e)}modifyGeometries(e,i){const r=this._changes.updates.length===0;for(const s of e){const a=this._changes.updates.pushNew();a.renderGeometry=this._validateRenderGeometry(s),a.updateType=i}switch(r&&this._changes.updates.length>0&&this.notifyChange("updating"),i){case Ve.TRANSFORMATION:case Ve.GEOMETRY:return this._notifyGraphicGeometryChanged(e);case Ve.VISIBILITY:return this._notifyGraphicVisibilityChanged(e)}}updateAnimation(e){let i=!1;return this._sortedMaterialRenderers.forAll(r=>i=!!r.updateAnimation&&r.updateAnimation(e)||i),i}shouldRender(e){return this._sortedMaterialRenderers.some(i=>i.prepareTechnique(e))}render(e){this._sortedMaterialRenderers.forAll(i=>{const r=i.prepareTechnique(e);r!=null&&i.renderNode(e,r)})}intersect(e,i,r,s,a){return this._geometries.forEach(n=>{if(s&&!s(n))return;this._intersectRenderGeometry(n,r,i,0,e,a);const o=this.rendererContext.longitudeCyclical;o&&(n.boundingSphere[0]-n.boundingSphere[3]<o.min&&this._intersectRenderGeometry(n,r,i,o.range,e,a),n.boundingSphere[0]+n.boundingSphere[3]>o.max&&this._intersectRenderGeometry(n,r,i,-o.range,e,a)),a++}),a}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear();let e=0;for(const i of this._materialRenderers.values())i.drapedPriority=e++,this._sortedMaterialRenderers.push(i);this._sortedMaterialRenderers.sort((i,r)=>{var s,a,n,o;return((s=r.materialReference)==null?void 0:s.renderPriority)===((a=i.materialReference)==null?void 0:a.renderPriority)?i.drapedPriority-r.drapedPriority:(((n=r.materialReference)==null?void 0:n.renderPriority)||0)-(((o=i.materialReference)==null?void 0:o.renderPriority)||0)})}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let e=0;e<this._changes.updates.length;){const i=this._changes.updates.data[e];this._pending.has(i.renderGeometry)?this._changes.updates.removeUnorderedIndex(e):e++}this._pending.clear()}_intersectRenderGeometry(e,i,r,s,a,n){if(!e.visible)return;let o=0;s+=e.transformation[12],o=e.transformation[13],Hr[0]=r[0]-s,Hr[1]=r[1]-o,e.screenToWorldRatio=this.rendererContext.screenToWorldRatio,e.material.intersectDraped(e,null,a,Hr,(c,l,h)=>{Pd(i,h,n,e.material.renderPriority,a,e.layerUid,e.graphicUid)},i)}_notifyGraphicGeometryChanged(e){if(this.drapeSource.notifyGraphicGeometryChanged==null)return;let i;for(const r of e){const s=r.graphicUid;s!=null&&s!==i&&(this.drapeSource.notifyGraphicGeometryChanged(s),i=s)}}_notifyGraphicVisibilityChanged(e){if(this.drapeSource.notifyGraphicVisibilityChanged==null)return;let i;for(const r of e){const s=r.graphicUid;s!=null&&s!==i&&(this.drapeSource.notifyGraphicVisibilityChanged(s),i=s)}}_validateRenderGeometries(e){for(const i of e)this._validateRenderGeometry(i);return e}_validateRenderGeometry(e){return e.localOrigin==null&&(e.localOrigin=this._localOriginFactory.getOrigin(ar(e.boundingSphere))),e}get test(){}};u([R()],Re.prototype,"drapeSource",void 0),u([R()],Re.prototype,"updating",null),u([R()],Re.prototype,"rctx",null),u([R({constructOnly:!0})],Re.prototype,"rendererContext",void 0),u([R()],Re.prototype,"_materials",null),u([R()],Re.prototype,"_localOriginFactory",null),u([R({readOnly:!0})],Re.prototype,"isEmpty",null),u([R()],Re.prototype,"_materialRenderers",void 0),u([R()],Re.prototype,"_geometries",void 0),Re=u([We("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],Re);let Dd=class{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return this.adds.size===0&&this.removes.size===0&&this.removed.size===0}has(e){return this.adds.has(e)||this.removes.has(e)||this.removed.has(e)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}};function Pd(t,e,i,r,s,a,n){const o=new md(a,n,e),c=l=>{l.set(ct.OVERLAY,o,t.dist,t.normal,t.transformation,i,r)};if((s.results.min.drapedLayerOrder==null||i>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||s.results.ground.dist<=s.results.min.dist)&&c(s.results.min),s.options.store!==bt.MIN&&(s.results.max.drapedLayerOrder==null||i<s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||s.results.ground.dist>s.results.max.dist)&&c(s.results.max),s.options.store===bt.ALL){const l=yd(s.ray);c(l),s.results.all.push(l)}}const Hr=Y();let Xn=class Zn extends Ri{initializeProgram(e){return new Ei(e.rctx,Zn.shader.get().build(),yr)}initializePipeline(){return this.configuration.hasAlpha?Xe({blending:Oc(rt.SRC_ALPHA,rt.ONE,rt.ONE_MINUS_SRC_ALPHA,rt.ONE_MINUS_SRC_ALPHA),colorWrite:at}):Xe({colorWrite:at})}};Xn.shader=new $i(uh,()=>xi(()=>Promise.resolve().then(()=>ap),void 0,import.meta.url));let Qn=class extends yn{constructor(){super(...arguments),this.hasAlpha=!1}};u([T()],Qn.prototype,"hasAlpha",void 0);let js=class extends $n{constructor(){super(...arguments),this.overlayIndex=vt.INNER,this.opacity=1}};function Kn(){const t=new Ci;return t.include(_n),t.fragment.uniforms.add(new ei("tex",e=>e.texture)),t.fragment.uniforms.add(new zl("overlayIdx",e=>e.overlayIndex)),t.fragment.uniforms.add(new ge("opacity",e=>e.opacity)),t.fragment.code.add(y`void main() {
vec2 overlayUV = overlayIdx == 0 ? vec2(uv.x * 0.5, uv.y) : vec2(uv.x * 0.5 + 0.5, uv.y);
fragColor = texture(tex, overlayUV) * opacity;
}`),t}const Id=Object.freeze(Object.defineProperty({__proto__:null,OverlayCompositingPassParameters:js,build:Kn},Symbol.toStringTag,{value:"Module"}));let eo=class to extends Ri{initializeProgram(e){return new Ei(e.rctx,to.shader.get().build(),yr)}initializePipeline(){return Xe({blending:Rn(rt.ONE,rt.ONE_MINUS_SRC_ALPHA),colorWrite:at})}};eo.shader=new $i(Id,()=>xi(()=>Promise.resolve().then(()=>np),void 0,import.meta.url));let Ie=class extends Bc{constructor(e){super(e),this._overlays=null,this._renderTargets=null,this._overlayParameters=new js,this.hasHighlights=!1,this._hasWater=!1,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new Ge,this._passParameters=new Ns,this._materials=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this.unloadedMemory=0,this.ignoresMemoryFactor=!1,this._camera=new wr,this.worldToPCSRatio=1,this.events=new hn,this.longitudeCyclical=null,this.produces=new Map([[G.DRAPED_MATERIAL,i=>i!==E.Highlight||this.hasHighlights],[G.DRAPED_WATER,()=>this._hasWater]]),this._hasTargetWithoutRasterImage=!1,this._hasDrapedFeatureSource=!1,this._hasDrapedRasterSource=!1}initialize(){const e=this.view._stage.renderer.fboCache,i=this.view._stage.renderView,{waterTextures:r,stippleTextures:s,markerTextures:a}=i;this._techniques=new ph({rctx:this._rctx,viewingMode:wt.Local,stippleTextures:s,markerTextures:a,waterTextures:r}),this._renderContext=new td(this._rctx,new rd(e,this.view.state.viewingMode),null),this.addHandles([br(()=>r.updating,()=>this.events.emit("content-changed"),Qs),br(()=>this.spatialReference,n=>this._localOriginFactory=new Zh(n),Qs),Vo(()=>this.view.allLayerViews,"after-changes",()=>this._sortedDrapeSourceRenderersDirty=!0)]),this._materials=new mh(i.textures,this._techniques,()=>{this.notifyChange("rendersOccludedDraped"),this.events.emit("content-changed"),this.notifyChange("updating"),this.notifyChange("isEmpty")},()=>this.events.emit("content-changed")),this._bindParameters.slot=G.DRAPED_MATERIAL,this._bindParameters.mainDepth=null,this._camera.near=1,this._camera.far=1e4,this._camera.relativeElevation=null,this._bindParameters.camera=this._camera,this._bindParameters.transparencyPassType=Q.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new Ul(ot(1,1,1))]),this.addHandles(this.view.resourceController.scheduler.registerTask(Ho.STAGE,this))}destroy(){this._renderers.forEach(e=>e.destroy()),this._renderers.clear(),this._debugTextureTechnique=nr(this._debugTextureTechnique),this._passParameters.texture=gi(this._passParameters.texture),this._techniques=dn(this._techniques),this.disposeOverlays()}get _bindParameters(){return this._renderContext.bindParameters}get _rctx(){return this.view._stage.renderView.renderingContext}get rctx(){return this._rctx}get materials(){return this._materials}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}initializeRenderContext(e){this.pluginContext=e}uninitializeRenderContext(){}renderNode(){}get updating(){return this._sortedDrapeSourceRenderersDirty||it(this._renderers,e=>e.updating)}get hasOverlays(){return this._overlays!=null&&this._renderTargets!=null}getMaterialRenderer(e){for(const i of this._renderers.values()){const r=i.getMaterialRenderer(e);if(r)return r}return null}get layers(){return this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers(),this._sortedRenderers.map(e=>e.drapeSource.layer).filter(e=>!!e)}createGeometryDrapeSourceRenderer(e){return this.createDrapeSourceRenderer(e,Re)}createDrapeSourceRenderer(e,i,r){const s=this._renderers.get(e);s!=null&&s.destroy();const a=new i({...r,rendererContext:this,drapeSource:e});return this._renderers.set(e,a),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in e&&this.addHandles(br(()=>e.fullOpacity,()=>this.events.emit("content-changed")),e),a}removeDrapeSourceRenderer(e){if(e==null)return;const i=this._renderers.get(e);i!=null&&(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(e),this.removeHandles(e),i.destroy())}computeValidity(){var e;return((e=this._renderTargets)==null?void 0:e.computeValidity())??0}releaseRenderTargets(){var e;(e=this._renderTargets)==null||e.dispose()}get overlays(){return this._overlays??[]}ensureDrapeTargets(e){this._hasTargetWithoutRasterImage=!!this._overlays&&xr(e,i=>i.drapeTargetType===is.WithoutRasterImage)}ensureDrapeSources(e){this._overlays?(this._hasDrapedFeatureSource=xr(e,i=>i.drapeSourceType===ui.Features),this._hasDrapedRasterSource=xr(e,i=>i.drapeSourceType===ui.RasterImage)):this._hasDrapedFeatureSource=this._hasDrapedRasterSource=!1}get _needsColorWithoutRasterImage(){return this._hasDrapedRasterSource&&this._hasDrapedFeatureSource&&this._hasTargetWithoutRasterImage}ensureOverlays(e,i,r=this._bindParameters.overlayStretch){this._overlays==null&&(this._renderTargets=new Xc(this.view._stage.renderer.fboCache),this._overlays=[new ba,new ba]),this.ensureDrapeTargets(e),this.ensureDrapeSources(i),this._bindParameters.overlayStretch=r}disposeOverlays(){this._overlays=null,this._renderTargets=gi(this._renderTargets),this.events.emit("textures-disposed")}getTexture(e){var i,r;if(e!=null)return e===fe.ColorNoRasterImage&&!this._needsColorWithoutRasterImage&&this._hasDrapedFeatureSource?(i=this._renderTargets)==null?void 0:i.getTexture(fe.Color):(r=this._renderTargets)==null?void 0:r.getTexture(e)}get running(){return this.updating}runTask(e){this._processDrapeSources(e,()=>!0)}_processDrapeSources(e,i){let r=!1;for(const[s,a]of this._renderers){if(e.done)break;(s.destroyed||i(s))&&a.commitChanges()&&(r=!0,e.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,r=!0,this._updateSortedDrapeSourceRenderers()),r&&(this._overlays!=null&&this._renderers.size===0&&this.disposeOverlays(),this.notifyChange("updating"),this.notifyChange("isEmpty"),this.events.emit("content-changed"),this.hasHighlights=it(this._renderers,s=>s.hasHighlights),this.notifyChange("rendersOccludedDraped"),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(Go,e=>e.updatePolicy===mi.SYNC)}get isEmpty(){return!Qi.OVERLAY_DRAW_DEBUG_TEXTURE&&!it(this._renderers,e=>!e.isEmpty)}get hasWater(){return this._hasWater}get rendersOccludedDraped(){const e=this._renderContext.renderOccludedMask;this._renderContext.renderOccludedMask=Za;const i=this._sortedRenderers.some(({renderer:r})=>r.shouldRender(this._renderContext));return this._renderContext.renderOccludedMask=e,i}renders(e){return Qi.OVERLAY_DRAW_DEBUG_TEXTURE&&e!==fe.Occluded||this._sortedRenderers.some(({renderer:i})=>i.shouldRender(this._renderContext))}get mode(){var e,i;return this.isEmpty?Bt.Disabled:(e=this._renderTargets)!=null&&e.getTexture(fe.WaterNormal)?Bt.EnabledWithWater:(i=this._renderTargets)!=null&&i.getTexture(fe.Color)?Bt.Enabled:Bt.Disabled}updateAnimation(e){let i=!1;return this._renderers.forEach(r=>i=r.updateAnimation(e)||i),i}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawOverlays(e){if(this._overlays&&this._renderTargets){for(const i of this._overlays)this.longitudeCyclical?i.setupGeometryViewsCyclical(this.longitudeCyclical):i.setupGeometryViewsDirect();for(const i of this._renderTargets.targets){if(i.content===fe.ColorNoRasterImage&&!this._needsColorWithoutRasterImage)continue;const r=this._drawTarget(vt.INNER,i,e),s=this._drawTarget(vt.OUTER,i,e);(r||s)&&i.fbo.generateMipMap()}}}_drawTarget(e,i,r){const s=this._overlays[e],a=s.canvasGeometries;if(a.numViews===0)return!1;const{alignPixelEnabled:n,contentPixelRatio:o}=r;this._screenToWorldRatio=o*s.mapUnitsPerPixel/this._bindParameters.overlayStretch;const c=i.output;if(this.isEmpty||c===E.Highlight&&!this.hasHighlights||c===E.Normal&&!this.hasWater||!s.hasSomeSizedView())return!1;const l=this._rctx;if(this._camera.pixelRatio=s.pixelRatio*o,this._renderContext.output=c,this._bindParameters.alignPixelEnabled=n,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=c===E.Normal?G.DRAPED_WATER:G.DRAPED_MATERIAL,i.content===fe.Occluded&&(this._renderContext.renderOccludedMask=Za),!this.renders(i.content))return this._renderContext.renderOccludedMask=ds,!1;const h=s.resolution;this._rctx.setViewport(e===vt.INNER?0:h,0,h,h);const d=2*s.resolution,p=s.resolution,f=i.fbo;if(f.bind(l,d,p),e===vt.INNER&&(l.setClearColor(0,0,0,0),l.clear(dr.COLOR_BUFFER_BIT)),Qi.OVERLAY_DRAW_DEBUG_TEXTURE&&i.content!==fe.Occluded)for(let g=0;g<a.numViews;g++)this._setViewParameters(a.extents[g],s),this._ensureDebugPatternResources(s.resolution,Ld[e]),this._rctx.bindTechnique(this._debugTextureTechnique,this._renderContext.bindParameters,this._passParameters),this._rctx.screen.draw();return this._sortedRenderers.forAll(({drapeSource:g,renderer:v})=>{if(i.content===fe.ColorNoRasterImage&&g.drapeSourceType===ui.RasterImage)return;const{fullOpacity:O}=g,S=O!=null&&O<1&&c===E.Color?this.bindTemporaryFramebuffer(d,p):null;for(let _=0;_<a.numViews;_++)this._setViewParameters(a.extents[_],s),v.render(this._renderContext);if(S){f.bind(l,d,p),this._overlayParameters.texture=S.getTexture(),this._overlayParameters.opacity=O,this._overlayParameters.overlayIndex=e;const _=this.pluginContext.techniques.acquire(eo);this._rctx.bindTechnique(_,this._renderContext.bindParameters,this._overlayParameters),this._rctx.screen.draw(),_.release(),S.release()}}),l.bindFramebuffer(null),this._renderContext.renderOccludedMask=ds,!0}bindTemporaryFramebuffer(e,i){var a;const r=this.view._stage.renderer.fboCache,s=r.acquire(e,i,"overlay tmp");return r.rctx.unbindTexture((a=s.fbo)==null?void 0:a.colorTexture),r.rctx.bindFramebuffer(s.fbo),r.rctx.clear(dr.COLOR_BUFFER_BIT),s}async reloadShaders(){await this._techniques.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(e,i,r,s){var n;this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers();let a=0;for(const{renderer:o}of this._sortedRenderers)a=((n=o.intersect)==null?void 0:n.call(o,e,i,r,s,a))??a}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),this._renderers.size===0)return;const e=this.view.map.allLayers,i=e.length;this._renderers.forEach((r,s)=>{const a=e.indexOf(s.layer),n=a>=0,o=s.renderGroup??(n?pr.MapLayer:pr.ViewLayer),c=i*o+(n?a:0);this._sortedRenderers.push(new Md(s,r,c))}),this._sortedRenderers.sort((r,s)=>r.index-s.index)}_setViewParameters(e,i){const r=this._camera;r.viewport=[0,0,i.resolution,i.resolution],Bo(r.projectionMatrix,0,e[2]-e[0],0,e[3]-e[1],r.near,r.far),Wo(r.viewMatrix,[-e[0],-e[1],0])}_updateHasWater(){const e=it(this._renderers,i=>i.hasWater);e!==this._hasWater&&(this._hasWater=e,this.events.emit("has-water",e))}_ensureDebugPatternResources(e,i){if(Z(this._passParameters.color,i[0],i[1],i[2]),this._passParameters.texture)return;const r=new Uint8Array(e*e*4);let s=0;for(let o=0;o<e;o++)for(let c=0;c<e;c++){const l=Math.floor(c/10),h=Math.floor(o/10);l<2||h<2||10*l>e-20||10*h>e-20?(r[s++]=255,r[s++]=255,r[s++]=255,r[s++]=255):(r[s++]=255,r[s++]=255,r[s++]=255,r[s++]=1&l&&1&h?1&c^1&o?0:255:1&l^1&h?0:128)}const a=new Ic(e);a.samplingMode=uc.NEAREST,this._passParameters.texture=new ts(this._rctx,a,r);const n=new Qn;n.hasAlpha=!0,this._debugTextureTechnique=this._techniques.acquire(Xn,n)}get test(){}};u([R()],Ie.prototype,"hasHighlights",void 0),u([R()],Ie.prototype,"_sortedDrapeSourceRenderersDirty",void 0),u([R()],Ie.prototype,"_techniques",void 0),u([R({constructOnly:!0})],Ie.prototype,"view",void 0),u([R()],Ie.prototype,"worldToPCSRatio",void 0),u([R()],Ie.prototype,"spatialReference",void 0),u([R({type:Boolean,readOnly:!0})],Ie.prototype,"updating",null),u([R()],Ie.prototype,"isEmpty",null),u([R({readOnly:!0})],Ie.prototype,"rendersOccludedDraped",null),Ie=u([We("esri.views.3d.terrain.OverlayRenderer")],Ie);let Md=class{constructor(e,i,r){this.drapeSource=e,this.renderer=i,this.index=r}};const Ld=[[1,.5,.5],[.5,.5,1]],Nd=-2,Za=$e.OccludeAndTransparent;var fs;(function(t){function e(n,o){const c=n[o],l=n[o+1],h=n[o+2];return Math.sqrt(c*c+l*l+h*h)}function i(n,o){const c=n[o],l=n[o+1],h=n[o+2],d=1/Math.sqrt(c*c+l*l+h*h);n[o]*=d,n[o+1]*=d,n[o+2]*=d}function r(n,o,c){n[o]*=c,n[o+1]*=c,n[o+2]*=c}function s(n,o,c,l,h,d=o){(h=h||n)[d]=n[o]+c[l],h[d+1]=n[o+1]+c[l+1],h[d+2]=n[o+2]+c[l+2]}function a(n,o,c,l,h,d=o){(h=h||n)[d]=n[o]-c[l],h[d+1]=n[o+1]-c[l+1],h[d+2]=n[o+2]-c[l+2]}t.length=e,t.normalize=i,t.scale=r,t.add=s,t.subtract=a})(fs||(fs={}));const Lt=fs,Gr=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],Fd=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],jd=[0,0,1,0,1,1,0,1],zd=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],io=new Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)io[6*t+e]=t;const gt=new Array(36);for(let t=0;t<6;t++)gt[6*t]=0,gt[6*t+1]=1,gt[6*t+2]=2,gt[6*t+3]=2,gt[6*t+4]=3,gt[6*t+5]=0;function ng(t,e){Array.isArray(e)||(e=[e,e,e]);const i=new Array(24);for(let r=0;r<8;r++)i[3*r]=Gr[r][0]*e[0],i[3*r+1]=Gr[r][1]*e[1],i[3*r+2]=Gr[r][2]*e[2];return new Ae(t,[[m.POSITION,new F(i,zd,3,!0)],[m.NORMAL,new F(Fd,io,3)],[m.UV0,new F(jd,gt,2)]])}const Br=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],Ud=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],Vd=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],Hd=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function og(t,e){Array.isArray(e)||(e=[e,e,e]);const i=new Array(18);for(let r=0;r<6;r++)i[3*r]=Br[r][0]*e[0],i[3*r+1]=Br[r][1]*e[1],i[3*r+2]=Br[r][2]*e[2];return new Ae(t,[[m.POSITION,new F(i,Vd,3,!0)],[m.NORMAL,new F(Ud,Hd,3)]])}const tr=re(-.5,0,-.5),ir=re(.5,0,-.5),rr=re(0,0,.5),sr=re(0,.5,0),Nt=Me(),Ft=Me(),Xt=Me(),Zt=Me(),Qt=Me();le(Nt,tr,sr),le(Ft,tr,ir),Be(Xt,Nt,Ft),te(Xt,Xt),le(Nt,ir,sr),le(Ft,ir,rr),Be(Zt,Nt,Ft),te(Zt,Zt),le(Nt,rr,sr),le(Ft,rr,tr),Be(Qt,Nt,Ft),te(Qt,Qt);const Wr=[tr,ir,rr,sr],Gd=[0,-1,0,Xt[0],Xt[1],Xt[2],Zt[0],Zt[1],Zt[2],Qt[0],Qt[1],Qt[2]],Bd=[0,1,2,3,1,0,3,2,1,3,0,2],Wd=[0,0,0,1,1,1,2,2,2,3,3,3];function lg(t,e){Array.isArray(e)||(e=[e,e,e]);const i=new Array(12);for(let r=0;r<4;r++)i[3*r]=Wr[r][0]*e[0],i[3*r+1]=Wr[r][1]*e[1],i[3*r+2]=Wr[r][2]*e[2];return new Ae(t,[[m.POSITION,new F(i,Bd,3,!0)],[m.NORMAL,new F(Gd,Wd,3)]])}function cg(t,e,i,r,s={uv:!0}){const a=-Math.PI,n=2*Math.PI,o=-Math.PI/2,c=Math.PI,l=Math.max(3,Math.floor(i)),h=Math.max(2,Math.floor(r)),d=(l+1)*(h+1),p=De(3*d),f=De(3*d),g=De(2*d),v=[];let O=0;for(let b=0;b<=h;b++){const C=[],x=b/h,$=o+x*c,w=Math.cos($);for(let V=0;V<=l;V++){const U=V/l,P=a+U*n,se=Math.cos(P)*w,j=Math.sin($),qe=-Math.sin(P)*w;p[3*O]=se*e,p[3*O+1]=j*e,p[3*O+2]=qe*e,f[3*O]=se,f[3*O+1]=j,f[3*O+2]=qe,g[2*O]=U,g[2*O+1]=x,C.push(O),++O}v.push(C)}const S=new Array;for(let b=0;b<h;b++)for(let C=0;C<l;C++){const x=v[b][C],$=v[b][C+1],w=v[b+1][C+1],V=v[b+1][C];b===0?(S.push(x),S.push(w),S.push(V)):b===h-1?(S.push(x),S.push($),S.push(w)):(S.push(x),S.push($),S.push(w),S.push(w),S.push(V),S.push(x))}const _=[[m.POSITION,new F(p,S,3,!0)],[m.NORMAL,new F(f,S,3,!0)]];return s.uv&&_.push([m.UV0,new F(g,S,2,!0)]),s.offset&&(_[0][0]=m.OFFSET,_.push([m.POSITION,new F(Float64Array.from(s.offset),Ds(S.length),3,!0)])),new Ae(t,_)}function hg(t,e,i,r){const s=qd(e,i);return new Ae(t,s)}function qd(t,e,i){let r,s;r=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],s=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];for(let c=0;c<r.length;c+=3)Lt.scale(r,c,t/Lt.length(r,c));let a={};function n(c,l){c>l&&([c,l]=[l,c]);const h=c.toString()+"."+l.toString();if(a[h])return a[h];let d=r.length;return r.length+=3,Lt.add(r,3*c,r,3*l,r,d),Lt.scale(r,d,t/Lt.length(r,d)),d/=3,a[h]=d,d}for(let c=0;c<e;c++){const l=s.length,h=new Array(4*l);for(let d=0;d<l;d+=3){const p=s[d],f=s[d+1],g=s[d+2],v=n(p,f),O=n(f,g),S=n(g,p),_=4*d;h[_]=p,h[_+1]=v,h[_+2]=S,h[_+3]=f,h[_+4]=O,h[_+5]=v,h[_+6]=g,h[_+7]=S,h[_+8]=O,h[_+9]=v,h[_+10]=O,h[_+11]=S}s=h,a={}}const o=aa(r);for(let c=0;c<o.length;c+=3)Lt.normalize(o,c);return[[m.POSITION,new F(aa(r),s,3,!0)],[m.NORMAL,new F(o,s,3,!0)]]}function dg(t,e,i,r,s,a,n,o,c=null){const l=i?Xr(i):D(),h=e?Xr(e):ot(0,0,1);n??(n=Y());const d=r?[255*r[0],255*r[1],255*r[2],r.length>3?255*r[3]:255]:[255,255,255,255],p=s!=null&&s.length===2?s:[1,1],f=Ds(1),g=[[m.POSITION,new F(l,f,3,!0)],[m.NORMAL,new F(h,f,3,!0)],[m.UV0,new F(n,f,n.length)],[m.COLOR,new F(d,f,4,!0)],[m.SIZE,new F(p,f,2)]];if(a!=null&&(a=[a[0],a[1],a[2],a[3]],g.push([m.CENTEROFFSETANDDISTANCE,new F(a,f,4)])),o){const v=[o[0],o[1],o[2],o[3]];g.push([m.FEATUREATTRIBUTE,new F(v,f,4)])}return new Ae(t,g,null,Kt.Point,c)}function ug(t,e,i,r,s,a=!0,n=!0){let o=0;const c=i,l=e;let h=re(0,o,0),d=re(0,o+l,0),p=re(0,-1,0),f=re(0,1,0);s&&(o=l,d=re(0,0,0),h=re(0,o,0),p=re(0,1,0),f=re(0,-1,0));const g=[d,h],v=[p,f],O=r+2,S=Math.sqrt(l*l+c*c);if(s)for(let w=r-1;w>=0;w--){const V=w*(2*Math.PI/r),U=re(Math.cos(V)*c,o,Math.sin(V)*c);g.push(U);const P=re(l*Math.cos(V)/S,-c/S,l*Math.sin(V)/S);v.push(P)}else for(let w=0;w<r;w++){const V=w*(2*Math.PI/r),U=re(Math.cos(V)*c,o,Math.sin(V)*c);g.push(U);const P=re(l*Math.cos(V)/S,c/S,l*Math.sin(V)/S);v.push(P)}const _=new Array,b=new Array;if(a){for(let w=3;w<g.length;w++)_.push(1),_.push(w-1),_.push(w),b.push(0),b.push(0),b.push(0);_.push(g.length-1),_.push(2),_.push(1),b.push(0),b.push(0),b.push(0)}if(n){for(let w=3;w<g.length;w++)_.push(w),_.push(w-1),_.push(0),b.push(w),b.push(w-1),b.push(1);_.push(0),_.push(2),_.push(g.length-1),b.push(1),b.push(2),b.push(v.length-1)}const C=De(3*O);for(let w=0;w<O;w++)C[3*w]=g[w][0],C[3*w+1]=g[w][1],C[3*w+2]=g[w][2];const x=De(3*O);for(let w=0;w<O;w++)x[3*w]=v[w][0],x[3*w+1]=v[w][1],x[3*w+2]=v[w][2];const $=[[m.POSITION,new F(C,_,3,!0)],[m.NORMAL,new F(x,b,3,!0)]];return new Ae(t,$)}function pg(t,e,i,r,s,a,n){const o=s?da(s):re(1,0,0),c=a?da(a):re(0,0,0);n??(n=!0);const l=Me();te(l,o);const h=Me();k(h,l,Math.abs(e));const d=Me();k(d,h,-.5),K(d,d,c);const p=re(0,1,0);Math.abs(1-yt(l,p))<.2&&Z(p,0,0,1);const f=Me();Be(f,l,p),te(f,f),Be(p,f,l);const g=2*r+(n?2:0),v=r+(n?2:0),O=De(3*g),S=De(3*v),_=De(2*g),b=new Array(3*r*(n?4:2)),C=new Array(3*r*(n?4:2));n&&(O[3*(g-2)]=d[0],O[3*(g-2)+1]=d[1],O[3*(g-2)+2]=d[2],_[2*(g-2)]=0,_[2*(g-2)+1]=0,O[3*(g-1)]=O[3*(g-2)]+h[0],O[3*(g-1)+1]=O[3*(g-2)+1]+h[1],O[3*(g-1)+2]=O[3*(g-2)+2]+h[2],_[2*(g-1)]=1,_[2*(g-1)+1]=1,S[3*(v-2)]=-l[0],S[3*(v-2)+1]=-l[1],S[3*(v-2)+2]=-l[2],S[3*(v-1)]=l[0],S[3*(v-1)+1]=l[1],S[3*(v-1)+2]=l[2]);const x=(P,se,j)=>{b[P]=se,C[P]=j};let $=0;const w=Me(),V=Me();for(let P=0;P<r;P++){const se=P*(2*Math.PI/r);k(w,p,Math.sin(se)),k(V,f,Math.cos(se)),K(w,w,V),S[3*P]=w[0],S[3*P+1]=w[1],S[3*P+2]=w[2],k(w,w,i),K(w,w,d),O[3*P]=w[0],O[3*P+1]=w[1],O[3*P+2]=w[2],_[2*P]=P/r,_[2*P+1]=0,O[3*(P+r)]=O[3*P]+h[0],O[3*(P+r)+1]=O[3*P+1]+h[1],O[3*(P+r)+2]=O[3*P+2]+h[2],_[2*(P+r)]=P/r,_[2*P+1]=1;const j=(P+1)%r;x($++,P,P),x($++,P+r,P),x($++,j,j),x($++,j,j),x($++,P+r,P),x($++,j+r,j)}if(n){for(let P=0;P<r;P++){const se=(P+1)%r;x($++,g-2,v-2),x($++,P,v-2),x($++,se,v-2)}for(let P=0;P<r;P++){const se=(P+1)%r;x($++,P+r,v-1),x($++,g-1,v-1),x($++,se+r,v-1)}}const U=[[m.POSITION,new F(O,b,3,!0)],[m.NORMAL,new F(S,C,3,!0)],[m.UV0,new F(_,b,2,!0)]];return new Ae(t,U)}function fg(t,e,i,r,s,a){r=r||10,s=s==null||s,ve(e.length>1);const n=[[0,0,0]],o=[],c=[];for(let l=0;l<r;l++){o.push([0,-l-1,-(l+1)%r-1]);const h=l/r*2*Math.PI;c.push([Math.cos(h)*i,Math.sin(h)*i])}return kd(t,c,e,n,o,s,a)}function kd(t,e,i,r,s,a,n=re(0,0,0)){const o=e.length,c=De(i.length*o*3+(6*r.length||0)),l=De(i.length*o*3+(r?6:0)),h=new Array,d=new Array;let p=0,f=0;const g=D(),v=D(),O=D(),S=D(),_=D(),b=D(),C=D(),x=D(),$=D(),w=D(),V=D(),U=D(),P=D(),se=Ti();Z($,0,1,0),le(v,i[1],i[0]),te(v,v),a?(K(x,i[0],n),te(O,x)):Z(O,0,0,1),Qa(v,O,$,$,_,O,Ka),H(S,O),H(U,_);for(let I=0;I<r.length;I++)k(b,_,r[I][0]),k(x,O,r[I][2]),K(b,b,x),K(b,b,i[0]),c[p++]=b[0],c[p++]=b[1],c[p++]=b[2];l[f++]=-v[0],l[f++]=-v[1],l[f++]=-v[2];for(let I=0;I<s.length;I++)h.push(s[I][0]>0?s[I][0]:-s[I][0]-1+r.length),h.push(s[I][1]>0?s[I][1]:-s[I][1]-1+r.length),h.push(s[I][2]>0?s[I][2]:-s[I][2]-1+r.length),d.push(0),d.push(0),d.push(0);let j=r.length;const qe=r.length-1;for(let I=0;I<i.length;I++){let J=!1;I>0&&(H(g,v),I<i.length-1?(le(v,i[I+1],i[I]),te(v,v)):J=!0,K(w,g,v),te(w,w),K(V,i[I-1],S),qo(i[I],w,se),ko(se,Yo(V,g),x)?(le(x,x,i[I]),te(O,x),Be(_,w,O),te(_,_)):Qa(w,S,U,$,_,O,Ka),H(S,O),H(U,_)),a&&(K(x,i[I],n),te(P,x));for(let ae=0;ae<o;ae++)if(k(b,_,e[ae][0]),k(x,O,e[ae][1]),K(b,b,x),te(C,b),l[f++]=C[0],l[f++]=C[1],l[f++]=C[2],K(b,b,i[I]),c[p++]=b[0],c[p++]=b[1],c[p++]=b[2],!J){const be=(ae+1)%o;h.push(j+ae),h.push(j+o+ae),h.push(j+be),h.push(j+be),h.push(j+o+ae),h.push(j+o+be);for(let Ye=0;Ye<6;Ye++){const Ct=h.length-6;d.push(h[Ct+Ye]-qe)}}j+=o}const ti=i[i.length-1];for(let I=0;I<r.length;I++)k(b,_,r[I][0]),k(x,O,r[I][1]),K(b,b,x),K(b,b,ti),c[p++]=b[0],c[p++]=b[1],c[p++]=b[2];const ke=f/3;l[f++]=v[0],l[f++]=v[1],l[f++]=v[2];const Tt=j-o;for(let I=0;I<s.length;I++)h.push(s[I][0]>=0?j+s[I][0]:-s[I][0]-1+Tt),h.push(s[I][2]>=0?j+s[I][2]:-s[I][2]-1+Tt),h.push(s[I][1]>=0?j+s[I][1]:-s[I][1]-1+Tt),d.push(ke),d.push(ke),d.push(ke);const Pi=[[m.POSITION,new F(c,h,3,!0)],[m.NORMAL,new F(l,d,3,!0)]];return new Ae(t,Pi)}function gg(t,e,i,r){ve(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),ve(e[0].length===3,"createPolylineGeometry(): malformed vertex"),ve(i==null||i.length===e.length,"createPolylineGeometry: need same number of points and normals"),ve(i==null||i[0].length===3,"createPolylineGeometry(): malformed normal");const s=$s(3*e.length),a=new Array(2*(e.length-1));let n=0,o=0;for(let l=0;l<e.length;l++){for(let h=0;h<3;h++)s[n++]=e[l][h];l>0&&(a[o++]=l-1,a[o++]=l)}const c=[[m.POSITION,new F(s,a,3,!0)]];if(i){const l=De(3*i.length);let h=0;for(let d=0;d<e.length;d++)for(let p=0;p<3;p++)l[h++]=i[d][p];c.push([m.NORMAL,new F(l,a,3,!0)])}return r&&c.push([m.COLOR,new F(r,fc(r.length/4),4)]),new Ae(t,c,null,Kt.Line)}function mg(t,e,i,r,s,a=0){const n=new Array(18),o=[[-i,a,s/2],[r,a,s/2],[0,e+a,s/2],[-i,a,-s/2],[r,a,-s/2],[0,e+a,-s/2]],c=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let l=0;l<6;l++)n[3*l]=o[l][0],n[3*l+1]=o[l][1],n[3*l+2]=o[l][2];return new Ae(t,[[m.POSITION,new F(n,c,3,!0)]])}function vg(t,e){const i=t.getMutableAttribute(m.POSITION).data;for(let r=0;r<i.length;r+=3){const s=i[r],a=i[r+1],n=i[r+2];Z(jt,s,a,n),ce(jt,jt,e),i[r]=jt[0],i[r+1]=jt[1],i[r+2]=jt[2]}}function _g(t,e=t){const i=t.attributes,r=i.get(m.POSITION).data,s=i.get(m.NORMAL).data;if(s){const a=e.getMutableAttribute(m.NORMAL).data;for(let n=0;n<s.length;n+=3){const o=s[n+1];a[n+1]=-s[n+2],a[n+2]=o}}if(r){const a=e.getMutableAttribute(m.POSITION).data;for(let n=0;n<r.length;n+=3){const o=r[n+1];a[n+1]=-r[n+2],a[n+2]=o}}}function qr(t,e,i,r,s){return!(Math.abs(yt(e,t))>s)&&(Be(i,t,e),te(i,i),Be(r,i,t),te(r,r),!0)}function Qa(t,e,i,r,s,a,n){return qr(t,e,s,a,n)||qr(t,i,s,a,n)||qr(t,r,s,a,n)}const Ka=.99619469809,jt=D();let yg=class{constructor(e,i={}){this.geometry=e,this.screenToWorldRatio=1,this._transformation=B(),this._shaderTransformation=null,this._boundingSphere=null,this.id=gn(),this.layerUid=i.layerUid,this.graphicUid=i.graphicUid,this.castShadow=i.castShadow??!1,i.objectShaderTransformation!=null&&this.objectShaderTransformationChanged(i.objectShaderTransformation)}get transformation(){return this._transformation}set transformation(e){Ze(this._transformation,e),this._boundingSphere=null}get boundingInfo(){return this.geometry.boundingInfo}objectShaderTransformationChanged(e){e==null?this._shaderTransformation=null:(this._shaderTransformation??(this._shaderTransformation=B()),nt(this._shaderTransformation,e,this.geometry.transformation)),this._boundingSphere=null}get boundingSphere(){return this.boundingInfo?(this._boundingSphere==null&&(this._boundingSphere??(this._boundingSphere=cn()),ce(ar(this._boundingSphere),this.boundingInfo.center,this.shaderTransformation),this._boundingSphere[3]=this.boundingInfo.radius*ln(this.shaderTransformation)),this._boundingSphere):Jo}get material(){return this.geometry.material}get type(){return this.geometry.type}get shaderTransformation(){return this._shaderTransformation??this.transformation}get attributes(){return this.geometry.attributes}get highlights(){return this.geometry.highlights}get occludees(){return this.geometry.occludees}get visible(){return this.geometry.visible}set visible(e){this.geometry.visible=e}};function ro(t){return t.type==="point"}let Og=class{constructor(e,i=null,r=0){this.array=e,this.spatialReference=i,this.offset=r}};function so(t){return"array"in t}function Ji(t,e,i="ground"){if(ro(e))return t.getElevation(e.x,e.y,e.z||0,e.spatialReference,i);if(so(e)){let r=e.offset;return t.getElevation(e.array[r++],e.array[r++],e.array[r]||0,e.spatialReference??t.spatialReference,i)}return t.getElevation(e[0],e[1],e[2]||0,t.spatialReference,i)}function Yd(t,e,i,r,s,a,n,o,c,l,h){const d=iu[h.mode];let p,f,g=0;if(lr(t,e,i,r,c.spatialReference,s,o))return d.requiresAlignment(h)?(g=d.applyElevationAlignmentBuffer(r,s,a,n,o,c,l,h),p=a,f=n):(p=r,f=s),lr(p,c.spatialReference,f,a,l.spatialReference,n,o)?g:void 0}function ao(t,e,i,r,s){const a=(ro(t)?t.z:so(t)?t.array[t.offset+2]:t[2])||0;switch(i.mode){case"on-the-ground":{const n=Ji(e,t,"ground")??0;return s.verticalDistanceToGround=0,s.sampledElevation=n,void(s.z=n)}case"relative-to-ground":{const n=Ji(e,t,"ground")??0,o=i.geometryZWithOffset(a,r);return s.verticalDistanceToGround=o,s.sampledElevation=n,void(s.z=o+n)}case"relative-to-scene":{const n=Ji(e,t,"scene")??0,o=i.geometryZWithOffset(a,r);return s.verticalDistanceToGround=o,s.sampledElevation=n,void(s.z=o+n)}case"absolute-height":{const n=i.geometryZWithOffset(a,r),o=Ji(e,t,"ground")??0;return s.verticalDistanceToGround=n-o,s.sampledElevation=o,void(s.z=n)}default:return void(s.z=0)}}function bg(t,e,i,r){return ao(t,e,i,r,Wt),Wt.z}function xg(t,e,i){return e==="on-the-ground"&&i==="on-the-ground"?t.staysOnTheGround:e===i||e!=="on-the-ground"&&i!=="on-the-ground"?e==null||i==null?t.definedChanged:gs.UPDATE:t.onTheGroundChanged}function Tg(t){return t==="relative-to-ground"||t==="relative-to-scene"}function Cg(t){return t!=="absolute-height"}function Ag(t,e,i,r,s){ao(e,i,s,r,Wt),Jd(t,Wt.verticalDistanceToGround);const a=Wt.sampledElevation,n=Ze(ru,t.transformation);return Xi[0]=e.x,Xi[1]=e.y,Xi[2]=Wt.z,Tc(e.spatialReference,Xi,n,r.spatialReference)?t.transformation=n:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function Jd(t,e){for(let i=0;i<t.geometries.length;++i){const r=t.geometries[i].getMutableAttribute(m.CENTEROFFSETANDDISTANCE);r&&r.data[3]!==e&&(r.data[3]=e,t.geometryVertexAttributeUpdated(t.geometries[i],m.CENTEROFFSETANDDISTANCE))}}function Xd(t,e,i,r,s,a){let n=0;const o=a.spatialReference;e*=3,r*=3;for(let c=0;c<s;++c){const l=t[e],h=t[e+1],d=t[e+2],p=a.getElevation(l,h,d,o,"ground")??0;n+=p,i[r]=l,i[r+1]=h,i[r+2]=p,e+=3,r+=3}return n/s}function Zd(t,e,i,r,s,a,n,o){let c=0;const l=o.calculateOffsetRenderUnits(n),h=o.featureExpressionInfoContext,d=a.spatialReference;e*=3,r*=3;for(let p=0;p<s;++p){const f=t[e],g=t[e+1],v=t[e+2],O=a.getElevation(f,g,v,d,"ground")??0;c+=O,i[r]=f,i[r+1]=g,i[r+2]=h==null?v+O+l:O+l,e+=3,r+=3}return c/s}function Qd(t,e,i,r,s,a,n,o){let c=0;const l=o.calculateOffsetRenderUnits(n),h=o.featureExpressionInfoContext,d=a.spatialReference;e*=3,r*=3;for(let p=0;p<s;++p){const f=t[e],g=t[e+1],v=t[e+2],O=a.getElevation(f,g,v,d,"scene")??0;c+=O,i[r]=f,i[r+1]=g,i[r+2]=h==null?v+O+l:O+l,e+=3,r+=3}return c/s}function Kd(t){const e=t.meterUnitOffset,i=t.featureExpressionInfoContext;return e!==0||i!=null}function eu(t,e,i,r,s,a,n,o){const c=o.calculateOffsetRenderUnits(n),l=o.featureExpressionInfoContext;e*=3,r*=3;for(let h=0;h<s;++h){const d=t[e],p=t[e+1],f=t[e+2];i[r]=d,i[r+1]=p,i[r+2]=l==null?f+c:c,e+=3,r+=3}return 0}let tu=class{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}};var gs;(function(t){t[t.NONE=0]="NONE",t[t.UPDATE=1]="UPDATE",t[t.RECREATE=2]="RECREATE"})(gs||(gs={}));const iu={"absolute-height":{applyElevationAlignmentBuffer:eu,requiresAlignment:Kd},"on-the-ground":{applyElevationAlignmentBuffer:Xd,requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:Zd,requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:Qd,requiresAlignment:()=>!0}},ru=B(),Wt=new tu,Xi=D(),su=()=>vr.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function au(t){return{cachedResult:t.cachedResult,arcade:t.arcade?{func:t.arcade.func,context:t.arcade.modules.arcadeUtils.createExecContext(null,{sr:t.arcade.context.spatialReference}),modules:t.arcade.modules}:null}}async function Eg(t,e,i,r){const s=t==null?void 0:t.expression;if(typeof s!="string")return null;const a=cu(s);if(a!=null)return{cachedResult:a};const n=await Zo();Qo(i);const o=n.arcadeUtils,c=o.createSyntaxTree(s);return o.dependsOnView(c)?(r!=null&&r.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:o.createFunction(c),context:o.createExecContext(null,{sr:e}),modules:n}}}function nu(t,e,i){return t.arcadeUtils.createFeature(e.attributes,e.geometry,i)}function ou(t,e){if(t!=null&&!no(t)){if(!e||!t.arcade)return void su().errorOncePerTick("Arcade support required but not provided");const i=e;i._geometry&&(i._geometry=Xo(i._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function lu(t){if(t!=null){if(no(t))return t.cachedResult;const e=t.arcade;let i=e==null?void 0:e.modules.arcadeUtils.executeFunction(e.func,e.context);return typeof i!="number"&&(t.cachedResult=0,i=0),i}return 0}function $g(t,e=!1){let i=t==null?void 0:t.featureExpressionInfo;const r=i==null?void 0:i.expression;return e||r==="0"||(i=null),i??null}const Dg={cachedResult:0};function no(t){return t.cachedResult!=null}function cu(t){return t==="0"?0:null}let Pg=class oo{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=Ko(e)}get requiresSampledElevationInfo(){return this.mode!=="absolute-height"}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,i){const r=this.calculateOffsetRenderUnits(i);return this.featureExpressionInfoContext!=null?r:e+r}calculateOffsetRenderUnits(e){let i=this._meterUnitOffset;const r=this.featureExpressionInfoContext;return r!=null&&(i+=lu(r)*this._metersPerElevationInfoUnit),i/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=el(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=e.offset??0}updateFeatureExpressionInfoContext(e,i,r){if(e==null)return void(this._featureExpressionInfoContext=null);const s=e==null?void 0:e.arcade;s&&i!=null&&r!=null?(this._featureExpressionInfoContext=au(e),ou(this._featureExpressionInfoContext,nu(s.modules,i,r))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const i=new oo;return e!=null&&i.setFromElevationInfo(e),i}};function hu(t){return t instanceof Float32Array&&t.length>=16}function du(t){return Array.isArray(t)&&t.length>=16}function uu(t){return hu(t)||du(t)}const lo=.5;function pu(t,e){t.include(Tn),t.attributes.add(m.POSITION,"vec3"),t.attributes.add(m.NORMAL,"vec3"),t.attributes.add(m.CENTEROFFSETANDDISTANCE,"vec4");const i=t.vertex;bs(i,e),wn(i,e),i.uniforms.add(new Le("viewport",(r,s)=>s.camera.fullViewport),new ge("polygonOffset",r=>r.shaderPolygonOffset),new ge("cameraGroundRelative",(r,s)=>s.camera.aboveGround?1:-1)),e.hasVerticalOffset&&Vl(i),i.constants.add("smallOffsetAngle","float",.984807753012208),i.code.add(y`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),i.code.add(y`
    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
      float pointGroundSign = ${e.multipassEnabled?y.float(0):y`sign(pointGroundDistance)`};
      if (pointGroundSign == 0.0) {
        pointGroundSign = cameraGroundRelative;
      }

      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground
      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise
      float groundRelative = cameraGroundRelative * pointGroundSign;

      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is
      // dropped is instead introduced using the ground-relative position of the symbol and the camera
      if (polygonOffset > .0) {
        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
        float factor = (1.0 - tanAlpha / viewport[2]);

        // same side of the terrain
        if (groundRelative > 0.0) {
          posView *= factor;
        }
        // opposite sides of the terrain
        else {
          posView /= factor;
        }
      }

      return groundRelative;
    }
  `),e.draped&&!e.hasVerticalOffset||Hl(i),e.draped||(i.uniforms.add(new ge("perDistancePixelRatio",(r,s)=>Math.tan(s.camera.fovY/2)/(s.camera.fullViewport[2]/2))),i.code.add(y`
    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
      float distanceToCamera = length(posView);

      // Compute offset in world units for a half pixel shift
      float pixelOffset = distanceToCamera * perDistancePixelRatio * ${y.float(lo)};

      // Apply offset along normal in the direction away from the ground surface
      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;

      // Apply the same offset also on the view space position
      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;

      posModel += modelOffset;
      posView += viewOffset;
    }
  `)),e.screenCenterOffsetUnitsEnabled&&Ai(i),e.hasScreenSizePerspective&&Cn(i),i.code.add(y`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      vec3 centerOffset = centerOffsetAndDistance.xyz;
      float pointGroundDistance = centerOffsetAndDistance.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.hasScreenSizePerspective&&(e.hasVerticalOffset||e.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.hasVerticalOffset?e.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.hasVerticalOffset?y`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${e.screenCenterOffsetUnitsEnabled?"":y`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${e.screenCenterOffsetUnitsEnabled?e.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${e.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `)}let fu=class{constructor(){this.factor=new en,this.factorAlignment=new en}},en=class{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}};function zs(t){t.uniforms.add(new Gl("alignPixelEnabled",(e,i)=>i.alignPixelEnabled)),t.code.add(y`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`),t.code.add(y`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
if (!alignPixelEnabled)
return clipCoord;
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`)}function gu(t,e){const{vertex:i,fragment:r}=t;i.include(zs),e.multipassEnabled&&t.varyings.add("depth","float"),i.code.add(y`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${e.multipassEnabled?"depth = projectAux.posView.z;":""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `),t.include(xs,e),r.code.add(y`
  void main() {
    fragColor = vec4(1);
    ${e.multipassEnabled?y`
        if(terrainDepthTest(depth)) {
          fragColor.g = 0.5;
        }`:""}
  }
  `)}function mu(t){t.vertex.uniforms.add(new ge("renderTransparentlyOccludedHUD",(e,i)=>i.hudRenderStyle===yi.Occluded?1:i.hudRenderStyle===yi.NotOccluded?0:.75),new Le("viewport",(e,i)=>i.camera.fullViewport),new ei("hudVisibilityTexture",(e,i)=>{var r;return(r=i.hudVisibility)==null?void 0:r.getTexture()})),t.vertex.include(zs),t.vertex.code.add(y`bool testHUDVisibility(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (renderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}function co(t){const e=new Ci,i=t.signedDistanceFieldEnabled;if(e.include(pu,t),e.include(Ts,t),t.occlusionPass)return e.include(gu,t),e;const{vertex:r,fragment:s}=e;e.include(Tn),s.include(Pn),s.include(Cs),e.include(Os,t),e.include(Ss,t),e.include(mu),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2"),e.varyings.add("voccluded","float"),r.uniforms.add(new Le("viewport",(l,h)=>h.camera.fullViewport),new Qr("screenOffset",(l,h)=>lt(ho,2*l.screenOffset[0]*h.camera.pixelRatio,2*l.screenOffset[1]*h.camera.pixelRatio)),new Qr("anchorPosition",l=>wi(l)),new Le("materialColor",l=>l.color)),Ai(r),i&&(r.uniforms.add(new Le("outlineColor",l=>l.outlineColor)),s.uniforms.add(new Le("outlineColor",l=>tn(l)?l.outlineColor:vs),new ge("outlineSize",l=>tn(l)?l.outlineSize:0))),t.pixelSnappingEnabled&&r.include(zs),t.hasScreenSizePerspective&&(Bl(r),Cn(r)),t.debugDrawLabelBorder&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(m.UV0,"vec2"),e.attributes.add(m.COLOR,"vec4"),e.attributes.add(m.SIZE,"vec2"),e.attributes.add(m.FEATUREATTRIBUTE,"vec4"),r.code.add(y`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${t.hasScreenSizePerspective?y`
            inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
            vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         `:y`
            inputSize = size;
            vec2 screenOffsetScaled = screenOffset;`}

      ${t.vvSize?"inputSize *= vvScale(featureAttribute).xx;":""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);
      bool visible = testHUDVisibility(posProj);
      voccluded = visible ? 0.0 : 1.0;
    `);const a=y`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`,n=t.pixelSnappingEnabled?i?y`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:y`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:y`posProj += quadOffset;`;r.code.add(y`
    ${t.occlusionTestEnabled?"if (visible) {":""}
    ${a}
    ${t.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${t.output===E.ObjectAndLayerIdColor?y`vcolor.a = 1.0;`:""}

    bool alphaDiscard = vcolor.a < ${y.float(_t)};
    ${i?`alphaDiscard = alphaDiscard && outlineColor.a < ${y.float(_t)};`:""}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${n}
      gl_Position = posProj;
    }

    vtc = uv;

    ${t.debugDrawLabelBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":""}
    vsize = inputSize;
    ${t.occlusionTestEnabled?y`} else { vtc = vec2(0.0);
      ${t.debugDrawLabelBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"}`:""}
  }
  `),s.uniforms.add(new ei("tex",l=>l.texture));const o=t.debugDrawLabelBorder?y`(isBorder > 0.0 ? 0.0 : ${y.float(na)})`:y.float(na),c=y`
    ${t.debugDrawLabelBorder?y`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`:""}

    ${t.sampleSignedDistanceFieldTexelCenter?y`
      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;
      `:y`
      vec2 samplePos = vtc;
      `}

    ${i?y`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${o} ||
          fillPixelColor.a + outlinePixelColor.a < ${y.float(_t)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        fragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${o}) {
          discard;
        }

        fragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:y`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${o}) {
            discard;
          }
          fragColor = texColor * premultiplyAlpha(vcolor);
          `}

    // Draw debug border with transparency, so that original texels along border are still partially visible
    ${t.debugDrawLabelBorder?y`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`:""}
  `;switch(t.output){case E.Color:t.transparencyPassType===Q.ColorAlpha&&(e.outputs.add("fragColor","vec4",0),e.outputs.add("fragAlpha","float",1)),s.code.add(y`
        void main() {
          ${c}
          ${t.transparencyPassType===Q.FrontFace?"fragColor.rgb /= fragColor.a;":""}
          ${t.transparencyPassType===Q.ColorAlpha?"fragAlpha = fragColor.a;":""}
        }`);break;case E.ObjectAndLayerIdColor:s.code.add(y`
        void main() {
          ${c}
          outputObjectAndLayerIdColor();
        }`);break;case E.Highlight:s.constants.add("occludedHighlightFlag","vec4",Wl),s.constants.add("unoccludedHighlightFlag","vec4",ql),s.code.add(y`
        void main() {
          ${c}
          if (voccluded == 1.0) {
            fragColor = occludedHighlightFlag;
          } else {
            fragColor = unoccludedHighlightFlag;
          }
        }`)}return e}function tn(t){return t.outlineColor[3]>0&&t.outlineSize>0}function wi(t,e=ho){return t.textureIsSignedDistanceField?vu(t.anchorPosition,t.distanceFieldBoundingBox,e):mr(e,t.anchorPosition),e}function vu(t,e,i){e!=null?lt(i,t[0]*(e[2]-e[0])+e[0],t[1]*(e[3]-e[1])+e[1]):lt(i,0,0)}const ho=Y(),_u=Object.freeze(Object.defineProperty({__proto__:null,build:co,calculateAnchorPosForRendering:wi},Symbol.toStringTag,{value:"Module"}));let uo=class po extends Ri{initializeConfiguration(e,i){i.spherical=e.viewingMode===wt.Global}initializeProgram(e){return new Ei(e.rctx,po.shader.get().build(this.configuration),yr)}initializePipeline(){const e=this.configuration.transparencyPassType,i=this.configuration,r=e===Q.NONE,s=e===Q.FrontFace,a=this.configuration.hasPolygonOffset?yu:null,n=i.draped?null:(r||s)&&i.output!==E.Highlight&&(i.depthEnabled||i.occlusionPass)?Ps:null;return Xe({blending:i.output===E.Color||i.output===E.Highlight?r?wu:As(e):null,depthTest:i.draped?null:{func:pc.LEQUAL},depthWrite:n,drawBuffers:Rs(e),colorWrite:at,polygonOffset:a})}get primitiveType(){return this.configuration.occlusionPass?hr.POINTS:hr.TRIANGLES}};uo.shader=new $i(_u,()=>xi(()=>Promise.resolve().then(()=>op),void 0,import.meta.url));const yu={factor:0,units:-4},wu=Rn(rt.ONE,rt.ONE_MINUS_SRC_ALPHA);let X=class extends _r{constructor(){super(...arguments),this.output=E.Color,this.transparencyPassType=Q.NONE,this.screenCenterOffsetUnitsEnabled=!1,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}};u([T({count:E.COUNT})],X.prototype,"output",void 0),u([T({count:Q.COUNT})],X.prototype,"transparencyPassType",void 0),u([T()],X.prototype,"screenCenterOffsetUnitsEnabled",void 0),u([T()],X.prototype,"spherical",void 0),u([T()],X.prototype,"occlusionTestEnabled",void 0),u([T()],X.prototype,"signedDistanceFieldEnabled",void 0),u([T()],X.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),u([T()],X.prototype,"vvSize",void 0),u([T()],X.prototype,"vvColor",void 0),u([T()],X.prototype,"hasVerticalOffset",void 0),u([T()],X.prototype,"hasScreenSizePerspective",void 0),u([T()],X.prototype,"debugDrawLabelBorder",void 0),u([T()],X.prototype,"hasSlicePlane",void 0),u([T()],X.prototype,"hasPolygonOffset",void 0),u([T()],X.prototype,"depthEnabled",void 0),u([T()],X.prototype,"pixelSnappingEnabled",void 0),u([T()],X.prototype,"draped",void 0),u([T()],X.prototype,"multipassEnabled",void 0),u([T()],X.prototype,"cullAboveGround",void 0),u([T()],X.prototype,"occlusionPass",void 0),u([T()],X.prototype,"objectAndLayerIdColorInstanced",void 0),u([T({constValue:!0})],X.prototype,"hasSliceInVertexProgram",void 0),u([T({constValue:!1})],X.prototype,"hasVvInstancing",void 0);class Ng extends Es{constructor(e){super(e,new Du),this._configuration=new X,this.produces=new Map([[G.HUD_MATERIAL,i=>Cr(i)&&!this.parameters.drawInSecondSlot],[G.LABEL_MATERIAL,i=>Cr(i)&&this.parameters.drawInSecondSlot],[G.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[G.DRAPED_MATERIAL,i=>Cr(i)]])}getConfiguration(e,i){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=i.slot===G.OCCLUSION_PIXELS&&this.parameters.occlusionTest,e===E.Color&&(this._configuration.debugDrawLabelBorder=!!Qi.LABELS_SHOW_BORDER),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=i.transparencyPassType,this._configuration.multipassEnabled=i.multipassEnabled,this._configuration.cullAboveGround=i.multipassTerrain.cullAboveGround,this._configuration}intersect(e,i,r,s,a,n){if(!(r.options.selectionMode&&r.options.hud&&e.visible&&r.point))return;const o=this.parameters,c=r.point,l=r.camera;let{scaleX:h,scaleY:d}=this._getScreenScale(e);h*=l.pixelRatio,d*=l.pixelRatio,mn(Yr,i),e.attributes.has(m.FEATUREATTRIBUTE)&&bu(Yr);const p=e.attributes.get(m.POSITION),f=e.attributes.get(m.SIZE),g=e.attributes.get(m.NORMAL),v=e.attributes.get(m.CENTEROFFSETANDDISTANCE);ve(p.size>=3);const O=wi(o),S=this.parameters.centerOffsetUnits==="screen";for(let _=0;_<p.data.length/p.size;_++){const b=_*p.size;Z(de,p.data[b],p.data[b+1],p.data[b+2]),ce(de,de,i);const C=_*f.size;Ke[0]=f.data[C]*h,Ke[1]=f.data[C+1]*d,ce(de,de,l.viewMatrix);const x=_*v.size;if(Z(Ce,v.data[x],v.data[x+1],v.data[x+2]),!S&&(de[0]+=Ce[0],de[1]+=Ce[1],Ce[2]!==0)){const w=Ce[2];te(Ce,de),le(de,de,k(Ce,Ce,w))}const $=_*g.size;if(Z(oi,g.data[$],g.data[$+1],g.data[$+2]),rn(oi,Yr,l,Jr),this._applyVerticalOffsetTransformationView(de,Jr,l,kr),l.applyProjection(de,me),me[0]>-1){S&&(Ce[0]||Ce[1])&&(me[0]+=Ce[0]*l.pixelRatio,Ce[1]!==0&&(me[1]+=kl(Ce[1],kr.factorAlignment)*l.pixelRatio),l.unapplyProjection(me,de)),me[0]+=this.parameters.screenOffset[0]*l.pixelRatio,me[1]+=this.parameters.screenOffset[1]*l.pixelRatio,me[0]=Math.floor(me[0]),me[1]=Math.floor(me[1]),Yl(Ke,kr.factor,Ke);const w=Ru*l.pixelRatio;let V=0;if(o.textureIsSignedDistanceField&&(V=o.outlineSize*l.pixelRatio/2),sn(c,me[0],me[1],Ke,w,V,o,O)){const U=r.ray;if(ce(an,de,kt(Tu,l.viewMatrix)),me[0]=c[0],me[1]=c[1],l.unprojectFromRenderScreen(me,de)){const P=D();H(P,U.direction);const se=1/He(P);k(P,P,se),n(Oi(U.origin,de)*se,P,-1,!0,1,an)}}}}}intersectDraped(e,i,r,s,a,n){const o=e.attributes.get(m.POSITION),c=e.attributes.get(m.SIZE),l=this.parameters,h=wi(l);let{scaleX:d,scaleY:p}=this._getScreenScale(e);d*=e.screenToWorldRatio,p*=e.screenToWorldRatio;const f=Eu*e.screenToWorldRatio;for(let g=0;g<o.data.length/o.size;g++){const v=g*o.size,O=o.data[v],S=o.data[v+1],_=g*c.size;Ke[0]=c.data[_]*d,Ke[1]=c.data[_+1]*p;let b=0;l.textureIsSignedDistanceField&&(b=l.outlineSize*e.screenToWorldRatio/2),sn(s,O,S,Ke,f,b,l,h)&&a(n.dist,n.normal,-1,!1)}}createBufferWriter(){return new Iu(this)}_updateScaleInfo(e,i,r){const s=this.parameters;s.screenSizePerspective!=null?oa(r,i,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),s.screenSizePerspectiveAlignment!=null?oa(r,i,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,i,r,s,a,n,o){const c=rn(i,r,a,Jr);return this._applyVerticalGroundOffsetView(e,c,a,o),this._applyVerticalOffsetTransformationView(o,c,a,n),this._applyPolygonOffsetView(o,c,s[3],a,o),this._applyCenterOffsetView(o,s,o),o}applyShaderOffsetsNDC(e,i,r,s,a){return this._applyCenterOffsetNDC(e,i,r,s),a!=null&&H(a,s),this._applyPolygonOffsetNDC(s,i,r,s),s}_applyPolygonOffsetView(e,i,r,s,a){const n=s.aboveGround?1:-1;let o=Math.sign(r);o===0&&(o=n);const c=n*o;if(this.parameters.shaderPolygonOffset<=0)return H(a,e);const l=Yt(Math.abs(i.cosAngle),.01,1),h=1-Math.sqrt(1-l*l)/l/s.viewport[2];return k(a,e,c>0?h:1/h),a}_applyVerticalGroundOffsetView(e,i,r,s){const a=He(e),n=r.aboveGround?1:-1,o=r.computeRenderPixelSizeAtDist(a)*lo,c=k(de,i.normal,n*o);return K(s,e,c),s}_applyVerticalOffsetTransformationView(e,i,r,s){var l;const a=this.parameters;if(!((l=a.verticalOffset)!=null&&l.screenLength)){if(a.screenSizePerspective||a.screenSizePerspectiveAlignment){const h=He(e);this._updateScaleInfo(s,h,i.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const n=He(e),o=a.screenSizePerspectiveAlignment??a.screenSizePerspective,c=Jl(r,n,a.verticalOffset,i.cosAngle,o);return this._updateScaleInfo(s,n,i.cosAngle),k(i.normal,i.normal,c),K(e,e,i.normal)}_applyCenterOffsetView(e,i,r){const s=this.parameters.centerOffsetUnits!=="screen";return r!==e&&H(r,e),s&&(r[0]+=i[0],r[1]+=i[1],i[2]&&(te(oi,r),K(r,r,k(oi,oi,i[2])))),r}_applyCenterOffsetNDC(e,i,r,s){const a=this.parameters.centerOffsetUnits!=="screen";return s!==e&&H(s,e),a||(s[0]+=i[0]/r.fullWidth*2,s[1]+=i[1]/r.fullHeight*2),s}_applyPolygonOffsetNDC(e,i,r,s){const a=this.parameters.shaderPolygonOffset;if(e!==s&&H(s,e),a){const n=r.aboveGround?1:-1,o=n*Math.sign(i[3]);s[2]-=(o||n)*a}return s}createGLMaterial(e){return new Ou(e)}calculateRelativeScreenBounds(e,i,r=qt()){return Su(this.parameters,e,i,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}_getScreenScale(e){const i=e.attributes.get(m.FEATUREATTRIBUTE);if(i==null)return{scaleX:1,scaleY:1};const r=tl(i.data,Au),[s,a]=Xl(Cu,this.parameters,r);return{scaleX:s,scaleY:a}}}class Ou extends Zl{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(uo,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function Su(t,e,i,r){r[0]=t.anchorPosition[0]*-e[0]+t.screenOffset[0]*i,r[1]=t.anchorPosition[1]*-e[1]+t.screenOffset[1]*i}function rn(t,e,i,r){return uu(e)&&(e=mn(xu,e)),il(r.normal,t,e),ce(r.normal,r.normal,i.viewInverseTransposeMatrix),r.cosAngle=yt(fo,$u),r}function bu(t){const e=t[0],i=t[1],r=t[2],s=t[3],a=t[4],n=t[5],o=t[6],c=t[7],l=t[8],h=1/Math.sqrt(e*e+i*i+r*r),d=1/Math.sqrt(s*s+a*a+n*n),p=1/Math.sqrt(o*o+c*c+l*l);return t[0]=e*h,t[1]=i*h,t[2]=r*h,t[3]=s*d,t[4]=a*d,t[5]=n*d,t[6]=o*p,t[7]=c*p,t[8]=l*p,t}function sn(t,e,i,r,s,a,n,o){let c=e-s-(o[0]>0?r[0]*o[0]:0),l=c+r[0]+2*s,h=i-s-(o[1]>0?r[1]*o[1]:0),d=h+r[1]+2*s;const p=n.distanceFieldBoundingBox;return n.textureIsSignedDistanceField&&p!=null&&(c+=r[0]*p[0],h+=r[1]*p[1],l-=r[0]*(1-p[2]),d-=r[1]*(1-p[3]),c-=a,l+=a,h-=a,d+=a),t[0]>c&&t[0]<l&&t[1]>h&&t[1]<d}const kr=new fu,de=D(),oi=D(),me=Ne(),fo=D(),an=D(),Yr=ys(),xu=ys(),Tu=B(),Ce=D(),Cu=D(),Au=Ne(),Jr={normal:fo,cosAngle:0},Ru=1,Eu=2,Ke=[0,0],$u=ot(0,0,1);class Du extends Ql{constructor(){super(...arguments),this.renderOccluded=$e.Occlude,this.isDecoration=!1,this.color=fi(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=un(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=fi(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.draped=!1}}const go=xt().vec3f(m.POSITION).vec3f(m.NORMAL).vec2f(m.UV0).vec4u8(m.COLOR).vec2f(m.SIZE).vec4f(m.CENTEROFFSETANDDISTANCE).vec4f(m.FEATUREATTRIBUTE),Pu=go.clone().vec4u8(m.OBJECTANDLAYERIDCOLOR);class Iu{constructor(e){this._material=e,this.vertexBufferLayout=st("enable-feature:objectAndLayerId-rendering")?Pu:go}elementCount(e){return 6*e.attributes.get(m.POSITION).indices.length}write(e,i,r,s,a){var S;Kl(r.attributes.get(m.POSITION),e,s.position,a,6),ec(r.attributes.get(m.NORMAL),i,s.normal,a,6);const n=r.attributes.get(m.UV0).data;let o,c,l,h;if(n==null||n.length<4){const _=this._material.parameters;o=0,c=0,l=_.texCoordScale[0],h=_.texCoordScale[1]}else o=n[0],c=n[1],l=n[2],h=n[3];l=Math.min(1.99999,l+1),h=Math.min(1.99999,h+1);let d=r.attributes.get(m.POSITION).indices.length,p=a;const f=s.uv0;for(let _=0;_<d;++_)f.set(p,0,o),f.set(p,1,c),p++,f.set(p,0,l),f.set(p,1,c),p++,f.set(p,0,l),f.set(p,1,h),p++,f.set(p,0,l),f.set(p,1,h),p++,f.set(p,0,o),f.set(p,1,h),p++,f.set(p,0,o),f.set(p,1,c),p++;tc(r.attributes.get(m.COLOR),4,s.color,a,6);const{data:g,indices:v}=r.attributes.get(m.SIZE);d=v.length;const O=s.size;p=a;for(let _=0;_<d;++_){const b=g[2*v[_]],C=g[2*v[_]+1];for(let x=0;x<6;++x)O.set(p,0,b),O.set(p,1,C),p++}if(r.attributes.get(m.CENTEROFFSETANDDISTANCE)?la(r.attributes.get(m.CENTEROFFSETANDDISTANCE),s.centerOffsetAndDistance,a,6):ca(s.centerOffsetAndDistance,a,6*d),r.attributes.get(m.FEATUREATTRIBUTE)?la(r.attributes.get(m.FEATUREATTRIBUTE),s.featureAttribute,a,6):ca(s.featureAttribute,a,6*d),r.objectAndLayerIdColor!=null){const _=(S=r.attributes.get(m.POSITION))==null?void 0:S.indices;if(_){const b=_.length,C=s.getField(m.OBJECTANDLAYERIDCOLOR,yc);ic(r.objectAndLayerIdColor,C,b,a,6)}}}}class Mu extends Es{intersect(e,i,r,s,a,n){return rc(e,r,s,a,void 0,n)}}function mo(t){const e=new Ci,{vertex:i,fragment:r,attributes:s,varyings:a}=e;bs(i,t),e.include(sc,t),e.include(ac,t),e.include(Os,t),e.include(Ss,t),s.add(m.POSITION,"vec3"),t.vvColor&&s.add(m.COLORFEATUREATTRIBUTE,"float"),a.add("vColor","vec4"),a.add("vpos","vec3");const n=t.multipassEnabled&&t.output===E.Color;n&&a.add("depth","float"),i.uniforms.add(new Le("eColor",c=>c.color)),i.code.add(y`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      forwardObjectAndLayerIdColor();

      ${t.hasVertexColors?"vColor *= eColor;":t.vvColor?"vColor = eColor * interpolateVVColor(colorFeatureAttribute);":"vColor = eColor;"}
      ${n?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = transformPosition(proj, view, vpos);
    }
  `),e.include(Ts,t),n&&e.include(xs,t),r.include(Cs);const o=t.output===E.Highlight;return o&&e.include(nc,t),t.transparencyPassType===Q.ColorAlpha&&(e.outputs.add("fragColor","vec4",0),e.outputs.add("fragAlpha","float",1)),r.code.add(y`
  void main() {
    discardBySlice(vpos);
    ${n?"terrainDepthTest(depth);":""}
    vec4 fColor = vColor;

    ${t.output===E.ObjectAndLayerIdColor?y`fColor.a = 1.0;`:""}

    if (fColor.a < ${y.float(_t)}) {
      discard;
    }

    ${t.output===E.Color?y`fragColor = highlightSlice(fColor, vpos); ${t.transparencyPassType===Q.ColorAlpha?y`
                  fragColor = premultiplyAlpha(fragColor);
                  fragAlpha = fragColor.a;`:""}`:""}
    ${o?y`outputHighlight();`:""};
    ${t.output===E.ObjectAndLayerIdColor?y`outputObjectAndLayerIdColor();`:""}
  }
  `),e}const Lu=Object.freeze(Object.defineProperty({__proto__:null,build:mo},Symbol.toStringTag,{value:"Module"}));let vo=class _o extends Ri{initializeProgram(e){return new Ei(e.rctx,_o.shader.get().build(this.configuration),yr)}_createPipeline(e,i){const r=this.configuration,s=e===Q.NONE,a=e===Q.FrontFace;return Xe({blending:r.output===E.Color&&r.transparent?s?Zi:As(e):null,culling:Sc(r.cullFace),depthTest:r.draped?null:{func:On(e)},depthWrite:r.draped?null:(s||a)&&r.writeDepth?Ps:null,drawBuffers:r.output===E.Depth?{buffers:[hi.NONE]}:Rs(e),colorWrite:at,stencilWrite:r.hasOccludees?Kr:null,stencilTest:r.hasOccludees?i?es:Sn:null,polygonOffset:s||a?r.polygonOffset?Nu:null:oc(r.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._createPipeline(this.configuration.transparencyPassType,!0),this._createPipeline(this.configuration.transparencyPassType,!1)}getPipeline(e){return e?this._occludeePipelineState:super.getPipeline()}};vo.shader=new $i(Lu,()=>xi(()=>Promise.resolve().then(()=>lp),void 0,import.meta.url));const Nu={factor:1,units:1};class ie extends _r{constructor(){super(...arguments),this.output=E.Color,this.cullFace=Is.None,this.transparencyPassType=Q.NONE,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.objectAndLayerIdColorInstanced=!1,this.vvColor=!1,this.draped=!1}}u([T({count:E.COUNT})],ie.prototype,"output",void 0),u([T({count:Is.COUNT})],ie.prototype,"cullFace",void 0),u([T({count:Q.COUNT})],ie.prototype,"transparencyPassType",void 0),u([T()],ie.prototype,"hasSlicePlane",void 0),u([T()],ie.prototype,"hasVertexColors",void 0),u([T()],ie.prototype,"transparent",void 0),u([T()],ie.prototype,"polygonOffset",void 0),u([T()],ie.prototype,"enableOffset",void 0),u([T()],ie.prototype,"writeDepth",void 0),u([T()],ie.prototype,"hasOccludees",void 0),u([T()],ie.prototype,"multipassEnabled",void 0),u([T()],ie.prototype,"cullAboveGround",void 0),u([T()],ie.prototype,"objectAndLayerIdColorInstanced",void 0),u([T()],ie.prototype,"vvColor",void 0),u([T()],ie.prototype,"draped",void 0),u([T({constValue:!1})],ie.prototype,"occlusionPass",void 0),u([T({constValue:!0})],ie.prototype,"hasVvInstancing",void 0),u([T({constValue:!1})],ie.prototype,"vvSize",void 0),u([T({constValue:!1})],ie.prototype,"vvOpacity",void 0);let Fg=class extends Mu{constructor(e){super(e,new ju),this.supportsEdges=!0,this.produces=new Map([[G.OPAQUE_MATERIAL,i=>i===E.Highlight||Ar(i)&&!this._isTransparent],[G.OPAQUE_NO_SSAO_DEPTH,i=>Ki(i)&&this.parameters.writeLinearDepth&&!this._isTransparent],[G.TRANSPARENT_MATERIAL,i=>Ar(i)&&this._isTransparent&&this.parameters.writeDepth],[G.TRANSPARENT_NO_SSAO_DEPTH,i=>Ki(i)&&this.parameters.writeLinearDepth&&this._isTransparent&&this.parameters.writeDepth],[G.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,i=>(Ar(i)||Ki(i)&&this.parameters.writeLinearDepth)&&this._isTransparent&&!this.parameters.writeDepth],[G.DRAPED_MATERIAL,i=>An(i)]]),this._configuration=new ie}getConfiguration(e,i){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasVertexColors=this.parameters.hasVertexColors&&!this.parameters.vvColor,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this._isTransparent,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=i.transparencyPassType,this._configuration.enableOffset=i.camera.relativeElevation<lc,this._configuration.multipassEnabled=i.multipassEnabled,this._configuration.cullAboveGround=i.multipassTerrain.cullAboveGround,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.draped=this.parameters.draped,this._configuration}createGLMaterial(e){return new Fu(e)}createBufferWriter(){const e=xt().vec3f(m.POSITION);return st("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(m.OBJECTANDLAYERIDCOLOR),this.parameters.vvColor?e.f32(m.COLORFEATUREATTRIBUTE):e.vec4u8(m.COLOR),new cc(e)}get _isTransparent(){return this.parameters.color[3]<1||this.parameters.forceTransparentMode}},Fu=class extends bn{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output===E.Color&&this._updateOccludeeState(e),this.ensureTechnique(vo,e)}},ju=class extends xn{constructor(){super(...arguments),this.color=vs,this.forceTransparentMode=!1,this.writeDepth=!0,this.writeLinearDepth=!1,this.hasVertexColors=!1,this.polygonOffset=!1,this.hasSlicePlane=!1,this.cullFace=Is.None,this.hasOccludees=!1,this.draped=!1}};var nn;(function(t){t[t.EnableFastUpdates=0]="EnableFastUpdates",t[t.DisableFastUpdates=1]="DisableFastUpdates",t[t.UpdateFastLocalOrigin=2]="UpdateFastLocalOrigin"})(nn||(nn={}));const ue={dash:[4,3],dot:[1,3],"long-dash":[8,3],"short-dash":[4,1],"short-dot":[1,1]},zu={dash:ue.dash,"dash-dot":[...ue.dash,...ue.dot],dot:ue.dot,"long-dash":ue["long-dash"],"long-dash-dot":[...ue["long-dash"],...ue.dot],"long-dash-dot-dot":[...ue["long-dash"],...ue.dot,...ue.dot],none:null,"short-dash":ue["short-dash"],"short-dash-dot":[...ue["short-dash"],...ue["short-dot"]],"short-dash-dot-dot":[...ue["short-dash"],...ue["short-dot"],...ue["short-dot"]],"short-dot":ue["short-dot"],solid:null},Uu=8;function Vu(t,e){return t==null?t:{pattern:t.slice(),pixelRatio:e}}function Vg(t){return{pattern:[t,t],pixelRatio:2}}function Hg(t){return t!=null&&t.type==="style"?Hu(t.style):null}function Hu(t){return t!=null?Vu(zu[t],Uu):null}function Gg(t,e,i=null){const r=[],s=e.mapPositions;Gu(e,r);const a=r[0][1].data,n=r[0][1].indices.length,o=Ds(n);return Bu(e,r,o),ku(e,r,o),Wu(e,r,o),qu(e,r,o),Yu(e,r,o),Ju(e,r,o),Xu(e,r,a),new Ae(t,r,s,Kt.Line,i)}function Gu(t,e){const{attributeData:{position:i},removeDuplicateStartEnd:r}=t,s=Zu(i)&&r,a=i.length/3-(s?1:0),n=new Array(2*(a-1)),o=s?i.slice(0,-3):i;let c=0;for(let l=0;l<a-1;l++)n[c++]=l,n[c++]=l+1;e.push([m.POSITION,new F(o,n,3,s)])}function Bu(t,e,i){if(t.attributeData.colorFeature!=null)return;const r=t.attributeData.color;e.push([m.COLOR,new F(r??_s,i,4)])}function Wu(t,e,i){t.attributeData.normal&&e.push([m.NORMAL,new F(t.attributeData.normal,i,3)])}function qu(t,e,i){t.attributeData.colorFeature!=null&&e.push([m.COLORFEATUREATTRIBUTE,new F([t.attributeData.colorFeature],i,1,!0)])}function ku(t,e,i){t.attributeData.sizeFeature==null&&e.push([m.SIZE,new F([t.attributeData.size??1],i,1,!0)])}function Yu(t,e,i){t.attributeData.sizeFeature!=null&&e.push([m.SIZEFEATUREATTRIBUTE,new F([t.attributeData.sizeFeature],i,1,!0)])}function Ju(t,e,i){t.attributeData.opacityFeature!=null&&e.push([m.OPACITYFEATUREATTRIBUTE,new F([t.attributeData.opacityFeature],i,1,!0)])}function Xu(t,e,i){if(t.overlayInfo==null||t.overlayInfo.renderCoordsHelper.viewingMode!==wt.Global||!t.overlayInfo.spatialReference.isGeographic)return;const r=$s(i.length),s=rl(t.overlayInfo.spatialReference);for(let d=0;d<r.length;d+=3)sl(i,d,r,d,s);const a=i.length/3,n=De(a+1);let o=Qu,c=Ku,l=0,h=0;lt(o,r[h++],r[h++]),h++,n[0]=0;for(let d=1;d<a+1;++d)d===a&&(h=0),lt(c,r[h++],r[h++]),h++,l+=al(o,c),n[d]=l,[o,c]=[c,o];e.push([m.DISTANCETOSTART,new F(n,e[0][1].indices,1,!0)])}function Zu(t){const e=t.length;return t[0]===t[e-3]&&t[1]===t[e-2]&&t[2]===t[e-1]}const Qu=Y(),Ku=Y();function Bg(t,e,i,r){const s=t.type==="polygon"?ur.CCW_IS_HOLE:ur.NONE,a=t.type==="polygon"?t.rings:t.paths,{position:n,outlines:o}=En(a,!!t.hasZ,s,t.spatialReference),c=$s(n.length),l=Yd(n,t.spatialReference,0,c,0,n,0,n.length/3,e,i,r),h=l!=null;return{lines:h?yo(o,n,c):[],projectionSuccess:h,sampledElevation:l}}function Wg(t,e){const i=t.type==="polygon"?ur.CCW_IS_HOLE:ur.NONE,r=t.type==="polygon"?t.rings:t.paths,{position:s,outlines:a}=En(r,!1,i),n=lr(s,t.spatialReference,0,s,e,0,s.length/3);for(let o=2;o<s.length;o+=3)s[o]=Nd;return{lines:n?yo(a,s):[],projectionSuccess:n}}function yo(t,e,i=null){const r=new Array;for(const{index:s,count:a}of t){if(a<=1)continue;const n=3*s,o=3*a;r.push({position:ua(e,3*s,3*a),mapPositions:i!=null?ua(i,n,o):void 0})}return r}function qg(t,e){if(t.type==="point")return et(t,e,!1);if(nl(t))switch(t.type){case"extent":return et(t.center,e,!1);case"polygon":return et(t.centroid,e,!1);case"polyline":return et(on(t),e,!0);case"mesh":return et(t.origin,e,!1)}else switch(t.type){case"extent":return et(ep(t),e,!0);case"polygon":return et(tp(t),e,!0);case"polyline":return et(on(t),e,!0)}}function on(t){const e=t.paths[0];if(!e||e.length===0)return null;const i=ol(e,ll(e)/2);return ws(i[0],i[1],i[2],t.spatialReference)}function ep(t){return ws(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),t.zmin!=null&&t.zmax!=null&&isFinite(t.zmin)&&isFinite(t.zmax)?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}function tp(t){const e=t.rings[0];if(!e||e.length===0)return null;const i=cl(t.rings,!!t.hasZ);return ws(i[0],i[1],i[2],t.spatialReference)}function et(t,e,i){const r=i?t:hl(t);return e&&t?dl(t,r,e)?r:null:r}function kg(t,e,i,r=0){if(t){e||(e=qt());const s=t;let a=.5*s.width*(i-1),n=.5*s.height*(i-1);return s.width<1e-7*s.height?a+=n/20:s.height<1e-7*s.width&&(n+=a/20),or(e,s.xmin-a-r,s.ymin-n-r,s.xmax+a+r,s.ymax+n+r),e}return null}function Yg(t,e,i=null){const r=ul(_s);return t!=null&&(r[0]=t[0],r[1]=t[1],r[2]=t[2]),e!=null?r[3]=e:t!=null&&t.length>3&&(r[3]=t[3]),i&&(r[0]*=i,r[1]*=i,r[2]*=i,r[3]*=i),r}function Jg(t=fl,e,i,r=1){const s=new Array(3);if(e==null||i==null)s[0]=1,s[1]=1,s[2]=1;else{let a,n=0;for(let o=2;o>=0;o--){const c=t[o];let l;const h=c!=null,d=o===0&&!a&&!h,p=i[o];c==="symbol-value"||d?l=p!==0?e[o]/p:1:h&&c!=="proportional"&&isFinite(c)&&(l=p!==0?c/p:1),l!=null&&(s[o]=l,a=l,n=Math.max(n,Math.abs(l)))}for(let o=2;o>=0;o--)s[o]==null?s[o]=a:s[o]===0&&(s[o]=.001*n)}for(let a=2;a>=0;a--)s[a]/=r;return pl(s)}function ip(t){return t.isPrimitive!=null}function Xg(t){return rp(ip(t)?[t.width,t.depth,t.height]:t)?null:"Symbol sizes may not be negative values"}function rp(t){const e=i=>i==null||i>=0;return Array.isArray(t)?t.every(e):e(t)}function Zg(t,e,i,r=B()){return t&&gl(r,r,-t/180*Math.PI),e&&ml(r,r,e/180*Math.PI),i&&vl(r,r,i/180*Math.PI),r}function Qg(t,e,i){if(i.minDemResolution!=null)return i.minDemResolution;const r=_l(e),s=yl(t)*r,a=wl(t)*r,n=Ol(t)*(e.isGeographic?1:r);return s===0&&a===0&&n===0?i.minDemResolutionForPoints:.01*Math.max(s,a,n)}const Kg=xt().vec3f(m.POSITION),em=xt().vec3f(m.POSITION).vec2f(m.UV0),tm=xt().vec3f(m.POSITION).vec4u8(m.COLOR),im=xt().vec3f(m.POSITION).vec2f(m.UV0).vec4u8(m.OBJECTANDLAYERIDCOLOR),sp=Object.freeze(Object.defineProperty({__proto__:null,build:Bn,ribbonlineNumRoundJoinSubdivisions:_i},Symbol.toStringTag,{value:"Module"})),ap=Object.freeze(Object.defineProperty({__proto__:null,TextureOnlyPassParameters:Ns,build:Mn},Symbol.toStringTag,{value:"Module"})),np=Object.freeze(Object.defineProperty({__proto__:null,OverlayCompositingPassParameters:js,build:Kn},Symbol.toStringTag,{value:"Module"})),op=Object.freeze(Object.defineProperty({__proto__:null,build:co,calculateAnchorPosForRendering:wi},Symbol.toStringTag,{value:"Module"})),lp=Object.freeze(Object.defineProperty({__proto__:null,build:mo},Symbol.toStringTag,{value:"Module"}));export{Og as $,mg as A,vg as B,mi as C,pg as D,fr as E,qg as F,fg as G,ug as H,kd as I,Mu as J,em as K,af as L,q as M,as as N,jc as O,Gt as P,Ng as Q,$g as R,Eg as S,ao as T,tu as U,_g as V,og as W,lg as X,ng as Y,hg as Z,Jd as _,pr as a,ou as a0,Qg as a1,Dg as a2,Yg as a3,gs as a4,Ag as a5,zs as a6,pu as a7,mu as a8,bf as a9,Jg as aA,Zg as aB,Qa as aC,rp as aD,im as aE,zf as aF,Zh as aG,kg as aH,xg as aa,Tg as ab,nu as ac,Xg as ad,Cg as ae,Ve as af,Fn as ag,St as ah,Ot as ai,_h as aj,zh as ak,Pn as al,vi as am,Gn as an,Nh as ao,mf as ap,ne as aq,Hg as ar,tm as as,Kg as at,fd as au,wd as av,ct as aw,bt as ax,yd as ay,qp as az,Hc as b,Wc as c,ff as d,ui as e,bg as f,gg as g,dg as h,jn as i,Fg as j,nn as k,Vg as l,yg as m,Hp as n,Pg as o,Wg as p,Gg as q,qc as r,Bg as s,Nd as t,gf as u,Yd as v,cg as w,wr as x,Ji as y,Vh as z};
