import{h8 as B,cz as y,cK as H,cL as k,iy as R,e4 as Y,dk as z,cN as q,cB as D,i5 as S,cJ as G,cR as P,cH as p,cG as v,ka as J,d5 as K,i$ as j,kb as Q}from"./index-eSY5-lt-.js";import{t as V,l as W}from"./Indices-bOD3sMcK.js";import{t as X}from"./basicInterfaces-IwaMq8O_.js";import{w as Z}from"./triangle-kBLwI83x.js";import{e as E}from"./VertexAttribute-h46lBfqy.js";import{t as tt}from"./doublePrecisionUtils-HJiLm-yC.js";var L;(function(e){e[e.Layer=0]="Layer",e[e.Object=1]="Object",e[e.Mesh=2]="Mesh",e[e.Line=3]="Line",e[e.Point=4]="Point",e[e.Material=5]="Material",e[e.Texture=6]="Texture",e[e.COUNT=7]="COUNT"})(L||(L={}));let it=class{constructor(){this.id=B()}},et=class{constructor(t){this.channel=t,this.id=B()}};function nt(e,t){return e==null&&(e=[]),e.push(t),e}function st(e,t){if(e==null)return null;const i=e.filter(s=>s!==t);return i.length===0?null:i}function pt(e,t,i,s,r){C[0]=e.get(t,0),C[1]=e.get(t,1),C[2]=e.get(t,2),tt(C,M,3),i.set(r,0,M[0]),s.set(r,0,M[1]),i.set(r,1,M[2]),s.set(r,1,M[3]),i.set(r,2,M[4]),s.set(r,2,M[5])}const C=y(),M=new Float32Array(6);class rt{constructor(t,i,s=i){this.data=t,this.size=i,this.stride=s}}class xt extends rt{constructor(t,i,s,r=!1,o=s){super(t,s,o),this.indices=i,this.exclusive=r}}function at(e){if(e.length<H)return Array.from(e);if(k(e))return Float64Array.from(e);if(!("BYTES_PER_ELEMENT"in e))return Array.from(e);switch(e.BYTES_PER_ELEMENT){case 1:return Uint8Array.from(e);case 2:return R(e)?Uint16Array.from(e):Int16Array.from(e);case 4:return Float32Array.from(e);default:return Float64Array.from(e)}}class U{constructor(t,i,s){this.primitiveIndices=t,this._numIndexPerPrimitive=i,this.position=s,this._children=void 0,z(t.length>=1),z(s.size===3||s.size===4);const{data:r,size:o,indices:h}=s;z(h.length%this._numIndexPerPrimitive==0),z(h.length>=t.length*this._numIndexPerPrimitive);const c=t.length;let a=o*h[this._numIndexPerPrimitive*t[0]];$.clear(),$.push(a);const u=q(r[a],r[a+1],r[a+2]),n=D(u);for(let m=0;m<c;++m){const f=this._numIndexPerPrimitive*t[m];for(let _=0;_<this._numIndexPerPrimitive;++_){a=o*h[f+_],$.push(a);let g=r[a];u[0]=Math.min(g,u[0]),n[0]=Math.max(g,n[0]),g=r[a+1],u[1]=Math.min(g,u[1]),n[1]=Math.max(g,n[1]),g=r[a+2],u[2]=Math.min(g,u[2]),n[2]=Math.max(g,n[2])}}this.bbMin=u,this.bbMax=n;const l=S(y(),this.bbMin,this.bbMax,.5);this.radius=.5*Math.max(Math.max(n[0]-u[0],n[1]-u[1]),n[2]-u[2]);let I=this.radius*this.radius;for(let m=0;m<$.length;++m){a=$.at(m);const f=r[a]-l[0],_=r[a+1]-l[1],g=r[a+2]-l[2],A=f*f+_*_+g*g;if(A<=I)continue;const T=Math.sqrt(A),w=.5*(T-this.radius);this.radius=this.radius+w,I=this.radius*this.radius;const O=w/T;l[0]+=f*O,l[1]+=_*O,l[2]+=g*O}this.center=l,$.clear()}getChildren(){if(this._children||G(this.bbMin,this.bbMax)<=1)return this._children;const t=S(y(),this.bbMin,this.bbMax,.5),i=this.primitiveIndices.length,s=new Uint8Array(i),r=new Array(8);for(let n=0;n<8;++n)r[n]=0;const{data:o,size:h,indices:c}=this.position;for(let n=0;n<i;++n){let l=0;const I=this._numIndexPerPrimitive*this.primitiveIndices[n];let m=h*c[I],f=o[m],_=o[m+1],g=o[m+2];for(let A=1;A<this._numIndexPerPrimitive;++A){m=h*c[I+A];const T=o[m],w=o[m+1],O=o[m+2];T<f&&(f=T),w<_&&(_=w),O<g&&(g=O)}f<t[0]&&(l|=1),_<t[1]&&(l|=2),g<t[2]&&(l|=4),s[n]=l,++r[l]}let a=0;for(let n=0;n<8;++n)r[n]>0&&++a;if(a<2)return;const u=new Array(8);for(let n=0;n<8;++n)u[n]=r[n]>0?new Uint32Array(r[n]):void 0;for(let n=0;n<8;++n)r[n]=0;for(let n=0;n<i;++n){const l=s[n];u[l][r[l]++]=this.primitiveIndices[n]}this._children=new Array;for(let n=0;n<8;++n)u[n]!==void 0&&this._children.push(new U(u[n],this._numIndexPerPrimitive,this.position));return this._children}static prune(){$.prune()}}const $=new Y({deallocator:null});function ht(e,t){if(!e)return!1;const{size:i,data:s,indices:r}=e;P(t,0,0,0),P(b,0,0,0);let o=0,h=0;for(let c=0;c<r.length-2;c+=3){const a=r[c]*i,u=r[c+1]*i,n=r[c+2]*i;P(d,s[a],s[a+1],s[a+2]),P(x,s[u],s[u+1],s[u+2]),P(N,s[n],s[n+1],s[n+2]);const l=Z(d,x,N);l?(p(d,d,x),p(d,d,N),v(d,d,1/3*l),p(t,t,d),o+=l):(p(b,b,d),p(b,b,x),p(b,b,N),h+=3)}return(h!==0||o!==0)&&(o!==0?(v(t,t,1/o),!0):h!==0&&(v(t,b,1/h),!0))}function ot(e,t){if(!e)return!1;const{size:i,data:s,indices:r}=e;P(t,0,0,0);let o=-1,h=0;for(let c=0;c<r.length;c++){const a=r[c]*i;o!==a&&(t[0]+=s[a],t[1]+=s[a+1],t[2]+=s[a+2],h++),o=a}return h>1&&v(t,t,1/h),h>0}function ct(e,t,i){if(!e)return!1;P(i,0,0,0),P(b,0,0,0);let s=0,r=0;const{size:o,data:h,indices:c}=e,a=c.length-1,u=a+(t?2:0);for(let n=0;n<u;n+=2){const l=n<a?n+1:0,I=c[n<a?n:a]*o,m=c[l]*o;d[0]=h[I],d[1]=h[I+1],d[2]=h[I+2],x[0]=h[m],x[1]=h[m+1],x[2]=h[m+2],v(d,p(d,d,x),.5);const f=J(d,x);f>0?(p(i,i,v(d,d,f)),s+=f):s===0&&(p(b,b,d),r++)}return s!==0?(v(i,i,1/s),!0):r!==0&&(v(i,b,1/r),!0)}const d=y(),x=y(),N=y(),b=y();class F extends it{constructor(t,i,s=null,r=L.Mesh,o=null,h=-1){super(),this.material=t,this.mapPositions=s,this.type=r,this.objectAndLayerIdColor=o,this.edgeIndicesLength=h,this.visible=!0,this._attributes=new Map,this._boundingInfo=null;for(const[c,a]of i)this._attributes.set(c,{...a,indices:V(a.indices)}),c===E.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._attributes.get(c).indices.length:this.edgeIndicesLength)}instantiate(t={}){const i=new F(t.material||this.material,[],this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._attributes.forEach((s,r)=>{s.exclusive=!1,i._attributes.set(r,s)}),i._boundingInfo=this._boundingInfo,i.transformation=t.transformation||this.transformation,i}get attributes(){return this._attributes}getMutableAttribute(t){let i=this._attributes.get(t);return i&&!i.exclusive&&(i={...i,exclusive:!0,data:at(i.data)},this._attributes.set(t,i)),i}setAttributeData(t,i){const s=this._attributes.get(t);s&&this._attributes.set(t,{...s,exclusive:!0,data:i})}get indexCount(){const t=this._attributes.values().next().value.indices;return(t==null?void 0:t.length)??0}get faceCount(){return this.indexCount/3}get boundingInfo(){return this._boundingInfo==null&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(t){return!!(this.type===L.Mesh?this._computeAttachmentOriginTriangles(t):this.type===L.Line?this._computeAttachmentOriginLines(t):this._computeAttachmentOriginPoints(t))&&(this._transformation!=null&&K(t,t,this._transformation),!0)}_computeAttachmentOriginTriangles(t){const i=this.attributes.get(E.POSITION);return ht(i,t)}_computeAttachmentOriginLines(t){const i=this.attributes.get(E.POSITION);return ct(i,ut(this.material.parameters,i),t)}_computeAttachmentOriginPoints(t){const i=this.attributes.get(E.POSITION);return ot(i,t)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const t=this.attributes.get(E.POSITION);if(!t||t.indices.length===0)return null;const i=this.type===L.Mesh?3:1;z(t.indices.length%i==0,"Indexing error: "+t.indices.length+" not divisible by "+i);const s=W(t.indices.length/i);return new U(s,i,t)}get transformation(){return this._transformation??j}set transformation(t){this._transformation=t&&t!==j?Q(t):null}addHighlight(){const t=new et(X.Highlight);return this.highlights=nt(this.highlights,t),t}removeHighlight(t){this.highlights=st(this.highlights,t)}}function ut(e,t){return!(!("isClosed"in e)||!e.isClosed)&&t.indices.length>2}export{F as I,et as a,st as b,rt as c,L as e,nt as n,it as r,pt as s,xt as t};
