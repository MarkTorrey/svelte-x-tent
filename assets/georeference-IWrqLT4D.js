import{bI as oe,l as B,e8 as ae,n as ie,aN as se,k as U,cy as v,iV as L,gW as N,gV as W,iW as le,da as ce,iX as fe,dh as ue,di as pe,cz as k,db as V,dz as q,iY as O,iZ as D,i_ as G,i$ as C,j0 as ge,d2 as me,cb as ye,hW as he,cN as de,d3 as Fe,j1 as Pe,iu as $e,gB as Ae}from"./index-eSY5-lt-.js";import{c as T}from"./spatialReferenceEllipsoidUtils-C7ZdwAmG.js";import{L as M,N as Te}from"./MeshTransform-sCiW0N8P.js";import{t as Y,o as Re}from"./DoubleArray-5XshLEpX.js";import{m as _e}from"./MeshGeoreferencedRelativeVertexSpace-5FoxqUmg.js";import{m as Ce}from"./MeshLocalVertexSpace-Hd9uQrLZ.js";import{n as F,s as I,r as A}from"./vec32-wV5-40u9.js";import{i as y,T as h}from"./BufferView-KywjVo63.js";let w=class extends oe(se){constructor(){super({}),this.type="georeferenced",this.isRelative=!1,this.isGeoreferenced=!0}};B([ae({georeferenced:"georeferenced"},{readOnly:!0})],w.prototype,"type",void 0),w=B([ie("esri.geometry.support.MeshGeoreferencedVertexSpace")],w);const we=w;function X(e,r){return e.isGeographic||e.isWebMercator&&((r==null?void 0:r.geographic)??!0)}function tr(e,r,n){const t=!e.isGeoreferenced;(n==null?void 0:n.geographic)!=null&&n.geographic!==t&&U.getLogger(r).warnOnce(`Specifying the 'geographic' parameter (${n.geographic}) for a Mesh vertex space of type "${e.type}" is not supported. This parameter will be ignored.`)}const x=U.getLogger("esri.geometry.support.meshUtils.normalProjection");function ve(e,r,n,t,o){return b(t)?(S(m.TO_PCPF,y.fromTypedArray(e),h.fromTypedArray(r),h.fromTypedArray(n),t,y.fromTypedArray(o)),o):(x.error("Cannot convert spatial reference to PCPF"),o)}function Me(e,r,n,t,o){return b(t)?(S(m.FROM_PCPF,y.fromTypedArray(e),h.fromTypedArray(r),h.fromTypedArray(n),t,y.fromTypedArray(o)),o):(x.error("Cannot convert to spatial reference from PCPF"),o)}function Oe(e,r,n){return v(e,r,0,n,T(r),0,e.length/3),n}function xe(e,r,n){return v(e,T(n),0,r,n,0,e.length/3),r}function Se(e,r,n){return O(f,n),F(r,e,f),D(f)||I(r,r),r}function be(e,r,n){if(O(f,n),F(r,e,f,4),D(f)||I(r,r,4),e!==r)for(let t=3;t<e.length;t+=4)r[t]=e[t];return r}function Ee(e,r,n,t,o){if(!b(t))return x.error("Cannot convert spatial reference to PCPF"),o;S(m.TO_PCPF,y.fromTypedArray(e,4*Float32Array.BYTES_PER_ELEMENT),h.fromTypedArray(r),h.fromTypedArray(n),t,y.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT));for(let a=3;a<e.length;a+=4)o[a]=e[a];return o}function Ve(e,r,n,t,o){if(!b(t))return x.error("Cannot convert to spatial reference from PCPF"),o;S(m.FROM_PCPF,y.fromTypedArray(e,16),h.fromTypedArray(r),h.fromTypedArray(n),t,y.fromTypedArray(o,16));for(let a=3;a<e.length;a+=4)o[a]=e[a];return o}function S(e,r,n,t,o,a){if(!r)return;const s=n.count,c=T(o);if(Z(o))for(let l=0;l<s;l++)t.getVec(l,R),r.getVec(l,g),M(c,R,_,c),L(f,_),e===m.FROM_PCPF&&N(f,f),W(g,g,f),a.setVec(l,g);else for(let l=0;l<s;l++){t.getVec(l,R),r.getVec(l,g),M(c,R,_,c),L(f,_);const i=le(n.get(l,1));let u=Math.cos(i);e===m.TO_PCPF&&(u=1/u),f[0]*=u,f[1]*=u,f[2]*=u,f[3]*=u,f[4]*=u,f[5]*=u,e===m.FROM_PCPF&&N(f,f),W(g,g,f),ce(g,g),a.setVec(l,g)}return a}function b(e){return Z(e)||je(e)}function Z(e){return e.isWGS84||fe(e)||ue(e)||pe(e)}function je(e){return e.isWebMercator}var m;(function(e){e[e.TO_PCPF=0]="TO_PCPF",e[e.FROM_PCPF=1]="FROM_PCPF"})(m||(m={}));const R=k(),g=k(),_=V(),f=q();function j(e,r,n){return X(r.spatialReference,n)?We(e,r,n):Ne(e,r,n)}function H(e,r=C){const{position:n,normal:t,tangent:o}=e;return{position:A(new Float64Array(n.length),n,r),normal:t!=null?Se(t,new Float32Array(t.length),r):null,tangent:o!=null?be(o,new Float32Array(o.length),r):null}}function J(e,r,n,t){const{position:o,normal:a,tangent:s}=e;return r.isRelative?j(H(e,n==null?void 0:n.localMatrix),r.getOriginPoint(t),{geographic:!r.isGeoreferenced}):{position:o,normal:a,tangent:s}}function ze(e,r,n){if(n!=null&&n.useTransform){const{position:t,normal:o,tangent:a}=e,{x:s,y:c,z:l}=r,i=de(s,c,l??0);return{vertexAttributes:{position:t,normal:o,tangent:a},vertexSpace:n.geographic??1?new Ce({origin:i}):new _e({origin:i}),transform:new Te}}return{vertexAttributes:j(e,r,n),vertexSpace:new we,transform:null}}function E(e,r,n){return X(r.spatialReference,n)?ke(e,r,n):K(e,r,n)}function Be(e,r,n,t,o){if(!r.isRelative)return E(e,t,o);const{spatialReference:a}=t,s=J(e,r,n,a);return t.equals(r.getOriginPoint(a))?K(s,t,o):E(s,t,o)}function Le({positions:e,transform:r,vertexSpace:n,inSpatialReference:t,outSpatialReference:o,outPositions:a,localMode:s}){const c=n.isRelative?n.origin:G,l=n.isRelative?(r==null?void 0:r.localMatrix)??C:C;if(n.isGeoreferenced){const p=a??Y(e.length);if(ge(l,C)?Re(p,e):A(p,e,l),!me(c,G)){const[re,ne,te]=c;for(let $=0;$<p.length;$+=3)p[$]+=re,p[$+1]+=ne,p[$+2]+=te}return v(p,t,0,p,o,0,p.length/3),p}let i=t;const u=T(t);i=o.isWebMercator&&s||!ye(t,u)?i:u,M(t,c,d,i),he(d,d,l);const P=a??Y(e.length);return A(P,e,d),v(P,i,0,P,o,0,P.length/3),P}function Ne(e,r,n){const t=new Float64Array(e.position.length),o=e.position,a=r.x,s=r.y,c=r.z??0,l=z(n?n.unit:null,r.spatialReference);for(let i=0;i<o.length;i+=3)t[i]=o[i]*l+a,t[i+1]=o[i+1]*l+s,t[i+2]=o[i+2]*l+c;return{position:t,normal:e.normal,tangent:e.tangent}}function We(e,r,n){const t=r.spatialReference,o=Q(r,n,d),a=new Float64Array(e.position.length),s=Ge(e.position,o,t,a),c=O(ee,o);return{position:s,normal:Ye(s,a,e.normal,c,t),tangent:Ue(s,a,e.tangent,c,t)}}function Ge(e,r,n,t){A(t,e,r);const o=new Float64Array(e.length);return xe(t,o,n)}function Ye(e,r,n,t,o){if(n==null)return null;const a=new Float32Array(n.length);return F(a,n,t),Me(a,e,r,o,a),a}function Ue(e,r,n,t,o){if(n==null)return null;const a=new Float32Array(n.length);F(a,n,t,4);for(let s=3;s<a.length;s+=4)a[s]=n[s];return Ve(a,e,r,o,a),a}function K(e,r,n){const t=new Float64Array(e.position.length),o=e.position,a=r.x,s=r.y,c=r.z??0,l=z(n?n.unit:null,r.spatialReference);for(let i=0;i<o.length;i+=3)t[i]=(o[i]-a)/l,t[i+1]=(o[i+1]-s)/l,t[i+2]=(o[i+2]-c)/l;return{position:t,normal:e.normal,tangent:e.tangent}}function ke(e,r,n){const t=r.spatialReference;Q(r,n,d);const o=Fe(Xe,d),a=new Float64Array(e.position.length),s=qe(e.position,t,o,a),c=O(ee,o);return{position:s,normal:De(e.normal,e.position,a,t,c),tangent:Ie(e.tangent,e.position,a,t,c)}}function Q(e,r,n){M(e.spatialReference,[e.x,e.y,e.z??0],n,T(e.spatialReference));const t=z(r?r.unit:null,e.spatialReference);return Pe(n,n,[t,t,t]),n}function qe(e,r,n,t){const o=Oe(e,r,t),a=new Float64Array(o.length);return A(a,o,n),a}function De(e,r,n,t,o){if(e==null)return null;const a=ve(e,r,n,t,new Float32Array(e.length));return F(a,a,o),a}function Ie(e,r,n,t,o){if(e==null)return null;const a=Ee(e,r,n,t,new Float32Array(e.length));return F(a,a,o,4),a}function z(e,r){if(e==null)return 1;const n=$e(r);return 1/Ae(n,"meters",e)}const d=V(),Xe=V(),ee=q(),or=Object.freeze(Object.defineProperty({__proto__:null,applyTransform:H,georeference:j,georeferenceApplyTransform:J,georeferenceByTransform:ze,project:Le,ungeoreference:E,ungeoreferenceByTransform:Be},Symbol.toStringTag,{value:"Module"}));export{ze as B,E as D,Be as E,Le as I,be as M,xe as O,Ee as R,j as U,H as V,Me as _,Se as a,or as g,Oe as h,ve as j,tr as o,we as p,J as q,X as r,Ve as v};
