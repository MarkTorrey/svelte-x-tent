import{ej as G,Q as E,h3 as L,i6 as J,aJ as z,l as v,ag as N,i7 as Z,hv as F,c4 as Q,o as U,fV as A,i8 as T,i9 as k,ia as B,cb as K,c1 as W,cU as tt,m as _,n as et,cz as nt,ib as it}from"./index-eSY5-lt-.js";import{e as st}from"./projectPointToVector-P8odY6kx.js";import{J as ot}from"./defaults--brCOrwa.js";function w(t,i,n,e){if(e==null||t.hasZ||(e=void 0),t.type==="point")return t.x+=i,t.y+=n,t.hasZ&&e!=null&&(t.z+=e),t;if(t.type==="multipoint"){const y=t.points;for(let l=0;l<y.length;l++)y[l]=q(y[l],i,n,e);return t}if(t.type==="extent")return t.xmin+=i,t.xmax+=i,t.ymin+=n,t.ymax+=n,e!=null&&(t.zmin??(t.zmin=0),t.zmin+=e,t.zmax??(t.zmax=0),t.zmax+=e),t;const a=G(t),s=t.type==="polyline"?t.paths:t.rings;for(let y=0;y<a.length;y++){const l=a[y];for(let o=0;o<l.length;o++)l[o]=q(l[o],i,n,e)}return"paths"in t?t.paths=s:t.rings=s,t}function ct(t,i,n,e,a){const s=t.clone(),y=e.resolution;if(s.type==="point"){if(a)w(s,i*y,-n*y);else{const l=e.state.transform,o=e.state.inverseTransform,r=l[0]*s.x+l[2]*s.y+l[4],h=l[1]*s.x+l[3]*s.y+l[5];s.x=o[0]*(r+i)+o[2]*(h+n)+o[4],s.y=o[1]*(r+i)+o[3]*(h+n)+o[5]}return s}if(s.type==="multipoint"){if(a)w(s,i*y,-n*y);else{const l=s.points,o=e.state.transform,r=e.state.inverseTransform;for(let h=0;h<l.length;h++){const p=l[h],m=o[0]*p[0]+o[2]*p[1]+o[4],d=o[1]*p[0]+o[3]*p[1]+o[5],u=r[0]*(m+i)+r[2]*(d+n)+r[4],f=r[1]*(m+i)+r[3]*(d+n)+r[5];l[h]=P(p,u,f,void 0)}}return s}if(s.type==="extent"){if(a)w(s,i*y,-n*y);else{const l=e.state.transform,o=e.state.inverseTransform,r=l[0]*s.xmin+l[2]*s.ymin+l[4],h=l[1]*s.xmin+l[3]*s.ymin+l[5],p=l[0]*s.xmax+l[2]*s.ymax+l[4],m=l[1]*s.xmax+l[3]*s.ymax+l[5];s.xmin=o[0]*(r+i)+o[2]*(h+n)+o[4],s.ymin=o[1]*(r+i)+o[3]*(h+n)+o[5],s.xmax=o[0]*(p+i)+o[2]*(m+n)+o[4],s.ymax=o[1]*(p+i)+o[3]*(m+n)+o[5]}return s}if(a)w(s,i*y,-n*y);else{const l=G(s),o=s.type==="polyline"?s.paths:s.rings,r=e.state.transform,h=e.state.inverseTransform;for(let p=0;p<l.length;p++){const m=l[p];for(let d=0;d<m.length;d++){const u=m[d],f=r[0]*u[0]+r[2]*u[1]+r[4],g=r[1]*u[0]+r[3]*u[1]+r[5],S=h[0]*(f+i)+h[2]*(g+n)+h[4],x=h[1]*(f+i)+h[3]*(g+n)+h[5];m[d]=P(u,S,x,void 0)}}"paths"in s?s.paths=o:s.rings=o}return s}function yt(t,i,n,e){if(t.type==="point"){const{x:u,y:f}=t,g=e?e[0]:u,S=e?e[1]:f,x=t.clone(),C=(u-g)*i+g,c=(f-S)*n+S;return x.x=C,x.y=c,x}if(t.type==="multipoint"){const u=G(t),f=E(),[g,S,x,C]=L(f,[u]),c=e?e[0]:(g+x)/2,$=e?e[1]:(C+S)/2,M=t.clone(),I=M.points;for(let D=0;D<I.length;D++){const H=I[D],[V,X]=H,Y=(V-c)*i+c,j=(X-$)*n+$;I[D]=P(H,Y,j,void 0)}return M}if(t.type==="extent"){const{xmin:u,xmax:f,ymin:g,ymax:S}=t,x=e?e[0]:(u+f)/2,C=e?e[1]:(S+g)/2,c=t.clone();if(c.xmin=(u-x)*i+x,c.ymax=(S-C)*n+C,c.xmax=(f-x)*i+x,c.ymin=(g-C)*n+C,c.xmin>c.xmax){const $=c.xmin,M=c.xmax;c.xmin=M,c.xmax=$}if(c.ymin>c.ymax){const $=c.ymin,M=c.ymax;c.ymin=M,c.ymax=$}return c}const a=G(t),s=E(),[y,l,o,r]=L(s,a),h=e?e[0]:(y+o)/2,p=e?e[1]:(r+l)/2,m=t.clone(),d=m.type==="polyline"?m.paths:m.rings;for(let u=0;u<a.length;u++){const f=a[u];for(let g=0;g<f.length;g++){const S=f[g],[x,C]=S,c=(x-h)*i+h,$=(C-p)*n+p;d[u][g]=P(S,c,$,void 0)}}return"paths"in m?m.paths=d:m.rings=d,m}function mt(t,i,n,e,a,s){const y=Math.sqrt((n-t)*(n-t)+(e-i)*(e-i));return Math.sqrt((a-t)*(a-t)+(s-i)*(s-i))/y}function ut(t,i,n,e=!1){const a=Math.atan2(i.y-n.y,i.x-n.x)-Math.atan2(t.y-n.y,t.x-n.x),s=Math.atan2(Math.sin(a),Math.cos(a));return e?s:J(s)}function q(t,i,n,e){return P(t,t[0]+i,t[1]+n,t[2]!=null&&e!=null?t[2]+e:void 0)}function P(t,i,n,e){const a=[i,n];return t.length>2&&a.push(e??t[2]),t.length>3&&a.push(t[3]),a}function lt(t){let i=0,n=0,e=0;return t?(t.type==="cim"&&t.data.symbol&&"symbolLayers"in t.data.symbol&&t.data.symbol.symbolLayers&&t.data.symbol.symbolLayers.map(a=>{a.type==="CIMVectorMarker"&&a.anchorPoint&&(Math.abs(a.anchorPoint.x)>i&&(i=a.anchorPoint.x),Math.abs(a.anchorPoint.y)>n&&(n=a.anchorPoint.y),a.size!=null&&a.size>e&&(e=a.size))}),i=z(i),n=z(n),e=z(e),{offsetX:i,offsetY:n,size:e}):{offsetX:i,offsetY:n,size:e}}let b=class extends N{set graphic(t){this._circleCollisionCache=null,this._originalSymbol=t.symbol,this._set("graphic",t),this.attachSymbolChanged()}get elevationInfo(){const{layer:t}=this.graphic,i=t&&"elevationInfo"in t?t.elevationInfo:null,n=Z(this.graphic),e=i?i.offset:0;return new F({mode:n,offset:e})}set focusedSymbol(t){t!==this._get("focusedSymbol")&&(this._set("focusedSymbol",t),this._updateGraphicSymbol(),this._circleCollisionCache=null)}grabbableForEvent(){return!0}set grabbing(t){t!==this._get("grabbing")&&(this._set("grabbing",t),this._updateGraphicSymbol())}set hovering(t){t!==this._get("hovering")&&(this._set("hovering",t),this._updateGraphicSymbol())}set selected(t){t!==this._get("selected")&&(this._set("selected",t),this._updateGraphicSymbol(),this.events.emit("select-changed",{action:t?"select":"deselect"}))}get _focused(){return this._get("hovering")||this._get("grabbing")}constructor(t){super(t),this.layer=null,this.interactive=!0,this.selectable=!1,this.grabbable=!0,this.dragging=!1,this.cursor=null,this.consumesClicks=!0,this.events=new Q.EventEmitter,this._circleCollisionCache=null,this._graphicSymbolChangedHandle=null,this._originalSymbol=null}destroy(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this._set("view",null)}intersectionDistance(t){const i=this.graphic;if(i.visible===!1)return null;const n=i.geometry;if(n==null)return null;const e=this._get("focusedSymbol"),a=e??i.symbol;return this.view.type==="2d"?this._intersectDistance2D(this.view,t,n,a):this._intersectDistance3D(this.view,t,i)}attach(){this.attachSymbolChanged(),this.layer!=null&&this.layer.add(this.graphic)}detach(){this.detachSymbolChanged(),this._resetGraphicSymbol(),this.layer!=null&&this.layer.remove(this.graphic)}attachSymbolChanged(){this.detachSymbolChanged(),this._graphicSymbolChangedHandle=U(()=>{var t;return(t=this.graphic)==null?void 0:t.symbol},t=>{t!=null&&t!==this.focusedSymbol&&t!==this._originalSymbol&&(this._originalSymbol=t,this._focused&&this.focusedSymbol!=null&&(this.graphic.symbol=this.focusedSymbol))},A)}detachSymbolChanged(){this._graphicSymbolChangedHandle!=null&&(this._graphicSymbolChangedHandle.remove(),this._graphicSymbolChangedHandle=null)}onElevationChange(){}onViewChange(){}_updateGraphicSymbol(){this.graphic.symbol=this._focused&&this.focusedSymbol!=null?this.focusedSymbol:this._originalSymbol}_resetGraphicSymbol(){this.graphic.symbol=this._originalSymbol}_intersectDistance2D(t,i,n,e){var y,l;if((e=e||ot(n))==null)return null;const a=1;let s=this._circleCollisionCache;if(n.type==="point"&&e.type==="cim"&&((y=e.data.symbol)==null?void 0:y.type)==="CIMPointSymbol"&&e.data.symbol.symbolLayers){const{offsetX:o,offsetY:r,size:h}=lt(e),p=T(i,R),m=h/2,d=t.toScreen(n),u=d.x+o,f=d.y+r;return k(p,[u,f])<m*m?a:null}if(n.type!=="point"||e.type!=="simple-marker")return B(i,n,t)?a:null;if(s==null||!s.originalPoint.equals(n)){const o=n,r=t.spatialReference;if(K(o.spatialReference,r)){const h=W(o,r);s={originalPoint:o.clone(),mapPoint:h,radiusPx:z(e.size)},this._circleCollisionCache=s}}if(s!=null){const o=T(i,R),r=(l=t.toScreen)==null?void 0:l.call(t,s.mapPoint);if(!r)return null;const h=s.radiusPx,p=r.x+z(e.xoffset),m=r.y-z(e.yoffset);return k(o,[p,m])<h*h?a:null}return null}_intersectDistance3D(t,i,n){const e=t.toMap(i,{include:[n]});return e&&st(e,O,t.renderSpatialReference)?tt(O,t.state.camera.eye):null}};v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"graphic",null),v([_()],b.prototype,"elevationInfo",null),v([_({constructOnly:!0,nonNullable:!0})],b.prototype,"view",void 0),v([_({value:null})],b.prototype,"focusedSymbol",null),v([_({constructOnly:!0})],b.prototype,"layer",void 0),v([_()],b.prototype,"interactive",void 0),v([_()],b.prototype,"selectable",void 0),v([_()],b.prototype,"grabbable",void 0),v([_({value:!1})],b.prototype,"grabbing",null),v([_()],b.prototype,"dragging",void 0),v([_()],b.prototype,"hovering",null),v([_({value:!1})],b.prototype,"selected",null),v([_()],b.prototype,"cursor",void 0),b=v([et("esri.views.interactive.GraphicManipulator")],b);const O=nt(),R=it();export{b as S,mt as a,lt as b,ct as i,ut as m,w as r,yt as s};
